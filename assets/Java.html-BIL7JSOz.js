import{_ as e,c as s,d as n,o as l}from"./app-ZTDKGR0h.js";const i="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-Bhf5aM4Z.png",t="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-1-iPxCGMFy.png",c="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-2-ieRhTKnK.png",r="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-3-C6dbUk4I.png",d="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-4-D32EtgVi.png",o="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-5-CF7NofQD.png",p="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-6-D25FI29m.png",v="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-7-DtvH1eBy.png",h="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-8-CKm7M898.png",g="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-10-DL5OoZzC.png",m="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-11-BVtM6rU3.png",u="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-12-Bn24LL-e.png",b="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-13-DebVP5sT.png",_="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-14-Bxj3rmpz.png",x="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-15-DovwfQD4.png",E="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-16-CiQ5y6Rc.png",J="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-17-BTdjHXN4.png",y="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-18-B4YHPI1T.png",f="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-19-DgWhLMz8.png",j="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-20-DZDRN9PP.png",A="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-21-BustxfTu.png",B="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-22-DhyJvkaA.png",F="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-23-tvX8N0pf.png",D="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-24-BXkrTWvr.png",k="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-25-D8cHxaPs.png",S={};function C(I,a){return l(),s("div",null,a[0]||(a[0]=[n(`<h1 id="java" tabindex="-1"><a class="header-anchor" href="#java"><span>Java</span></a></h1><h2 id="_1-编译" tabindex="-1"><a class="header-anchor" href="#_1-编译"><span>1.编译</span></a></h2><p>在<code>JAVA_HOME</code>的<code>bin</code>目录下找到很多可执行文件：</p><ul><li>java：这个可执行程序其实就是JVM，运行Java程序，就是启动JVM，然后让JVM执行指定的编译后的代码；</li><li>javac：这是Java的编译器，它用于把Java源码文件（以<code>.java</code>后缀结尾）编译为Java字节码文件（以<code>.class</code>后缀结尾）；</li><li>jar：用于把一组<code>.class</code>文件打包成一个<code>.jar</code>文件，便于发布；</li><li>javadoc：用于从Java源码中自动提取注释并生成文档；</li><li>jdb：Java调试器，用于开发阶段的运行调试。</li></ul><hr><h2 id="_2-oop" tabindex="-1"><a class="header-anchor" href="#_2-oop"><span>2.OOP</span></a></h2><ul><li>重载(Overload):方法名相同，参数不同，返回值类型相同。</li><li>重写(Override):用于多态，子类重写父类的方法。</li><li>抽象类(abstract):必须有方法是抽象方法，不用写内容，重在规范约束，要求子类必须重写。</li><li>接口(interface):抽象类中没有字段，全部都是抽象方法，则可以改为接口。接口定义的所有方法默认都是public abstract的。一个子类可以继承多个接口。</li></ul><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">abstract class</th><th style="text-align:center;">interface</th></tr></thead><tbody><tr><td style="text-align:center;">继承</td><td style="text-align:center;">只能extends一个class</td><td style="text-align:center;">可以implements多个interface</td></tr><tr><td style="text-align:center;">字段</td><td style="text-align:center;">可以定义实例字段</td><td style="text-align:center;">不能定义实例字段</td></tr><tr><td style="text-align:center;">抽象方法</td><td style="text-align:center;">可以定义抽象方法</td><td style="text-align:center;">可以定义抽象方法</td></tr><tr><td style="text-align:center;">非抽象方法</td><td style="text-align:center;">可以定义非抽象方法</td><td style="text-align:center;">可以定义default方法</td></tr></tbody></table><ul><li>静态方法经常用于工具类</li></ul><hr><h2 id="_3-命名空间" tabindex="-1"><a class="header-anchor" href="#_3-命名空间"><span>3.命名空间</span></a></h2><h3 id="_3-1-包" tabindex="-1"><a class="header-anchor" href="#_3-1-包"><span>3.1 包</span></a></h3><ol><li>package说明</li></ol><ul><li>一个类总是属于某个包（包名.类名）</li><li>在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。</li><li>包可以是多层结构，用<code>.</code>隔开。例如：<code>java.util</code>。</li><li>位于同一个包的类，可以访问包作用域的字段和方法。</li><li>不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。</li></ul><ol start="2"><li>Java编译器最终编译出的<code>.class</code>文件只使用_完整类名_，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</li></ol><ul><li><p>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</p></li><li><p>如果是简单类名，按下面的顺序依次查找：</p><ul><li>查找当前<code>package</code>是否存在这个<code>class</code>；</li><li>查找<code>import</code>的包是否包含这个<code>class</code>；</li><li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li></ul></li><li><p>如果按照上面的规则还无法确定类名，则编译报错。</p></li></ul><ol start="3"><li>编写class的时候，编译器会自动帮我们做两个import动作：</li></ol><ul><li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</li><li>默认自动<code>import java.lang.*</code>。</li></ul><blockquote><p>[!NOTE] 包名必须完全一致，包没有父子关系，<code>com.apache</code>和<code>com.apache.abc</code>是不同的包。</p></blockquote><blockquote><p>[!INFO] 用<code>final</code>修饰<code>class</code>可以阻止被继承。用<code>final</code>修饰方法可以防止被重写。用<code>final</code>修饰字段可以防止被修改值。</p></blockquote><ol start="4"><li>Java核心类库</li></ol><ul><li>java.lang包 – 该包是Java语言的核心包，并且该包中的所有内容由Java虚拟机自动导入。如：System类、String类、…</li><li>java.util包 – 该包是Java语言的工具包，里面提供了大量工具类以及集合类等。如：Scanner类、Random类、List集合、…</li><li>java.io包 – 该包是Java语言中的输入输出包，里面提供了大量读写文件相关的类等。如：FileInputStream类、FileOutputStream类、…</li><li>java.net包 – 该包是Java语言中的网络包，里面提供了大量网络编程相关的类等。如：ServerSocket类、Socket类、…</li><li>java.sql 包 – 该包是Java语言中的数据包，里面提供了大量操作数据库的类和接口等。如：DriverManager类、Connection接口、</li></ul><h3 id="_3-2-classpath" tabindex="-1"><a class="header-anchor" href="#_3-2-classpath"><span>3.2 classpath</span></a></h3><ul><li><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code>。所以，<code>classpath</code>就是一组目录的集合，它设置的搜索路径与操作系统相关。</li><li>在IDE中运行Java程序，IDE自动传入的<code>-cp</code>参数是当前工程的<code>bin</code>目录和引入的jar包。而在命令行中应当明确指出，例如<code> java -cp .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello</code>。（<code>-cp</code>也可以写全就是<code>-classpath</code>）</li></ul><h3 id="_3-3-jar" tabindex="-1"><a class="header-anchor" href="#_3-3-jar"><span>3.3 jar</span></a></h3><ul><li>如果有很多<code>.class</code>文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。</li><li>jar包就是用来干这个事的，它可以把<code>package</code>组织的目录层级，以及各个目录下的所有文件（包括<code>.class</code>文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。<code>java -cp ./hello.jar abc.xyz.Hello</code></li></ul><blockquote><p>[!NOTE] jar只是用于存放class的容器，它并不关心class之间的依赖。</p></blockquote><h3 id="_3-4-class版本" tabindex="-1"><a class="header-anchor" href="#_3-4-class版本"><span>3.4 class版本</span></a></h3><ul><li>Java 8，Java 11，Java 17，是指JDK的版本，也就是JVM的版本，更确切地说，就是<code>java.exe</code>这个程序的版本。</li><li>Java 11对应的class文件版本是55，而Java 17对应的class文件版本是61。</li></ul><h3 id="_3-5-模块-module" tabindex="-1"><a class="header-anchor" href="#_3-5-模块-module"><span>3.5 模块（Module）</span></a></h3><ul><li><p>一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫<code>rt.jar</code>，一共有60多M。所以要运行main函数就得设置<code>classpath</code>搜索好多路径的jar包。</p></li><li><p>如果<code>a.jar</code>必须依赖另一个<code>b.jar</code>才能运行，那我们应该给<code>a.jar</code>加点说明<code>module-info.class</code>啥的，让程序在编译和运行的时候能自动定位到<code>b.jar</code>，这种自带“依赖关系”的class容器就是模块。</p></li></ul><blockquote><p>[!NOTE] 把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。</p></blockquote><hr><h2 id="_4-boxing" tabindex="-1"><a class="header-anchor" href="#_4-boxing"><span>4. Boxing</span></a></h2><p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p><table><thead><tr><th style="text-align:center;">基本类型</th><th style="text-align:center;">对应的引用类型</th></tr></thead><tbody><tr><td style="text-align:center;">boolean</td><td style="text-align:center;">java.lang.Boolean</td></tr><tr><td style="text-align:center;">byte</td><td style="text-align:center;">java.lang.Byte</td></tr><tr><td style="text-align:center;">short</td><td style="text-align:center;">java.lang.Short</td></tr><tr><td style="text-align:center;">int</td><td style="text-align:center;">java.lang.Integer</td></tr><tr><td style="text-align:center;">long</td><td style="text-align:center;">java.lang.Long</td></tr><tr><td style="text-align:center;">float</td><td style="text-align:center;">java.lang.Float</td></tr><tr><td style="text-align:center;">double</td><td style="text-align:center;">java.lang.Double</td></tr><tr><td style="text-align:center;">char</td><td style="text-align:center;">java.lang.Character</td></tr></tbody></table><blockquote><p>[!NOTE] 所有的包装类型都是不变类。<code>BigInteger</code>和<code>Integer</code>、<code>Long</code>一样，也是不可变类，总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！</p></blockquote><h2 id="_5-enum" tabindex="-1"><a class="header-anchor" href="#_5-enum"><span>5. Enum</span></a></h2><p><code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点：</p><ul><li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li><li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li><li>定义的每个实例都是引用类型的唯一实例；</li><li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li></ul><hr><h2 id="_6-exception" tabindex="-1"><a class="header-anchor" href="#_6-exception"><span>6. Exception</span></a></h2><ol><li>Java标准库定义的常用异常包括：</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">Exception</span>
<span class="line">├─ RuntimeException</span>
<span class="line">│  ├─ NullPointerException(NPE)</span>
<span class="line">│  ├─ IndexOutOfBoundsException</span>
<span class="line">│  ├─ SecurityException</span>
<span class="line">│  └─ IllegalArgumentException</span>
<span class="line">│     └─ NumberFormatException</span>
<span class="line">├─ IOException</span>
<span class="line">│  ├─ UnsupportedCharsetException</span>
<span class="line">│  ├─ FileNotFoundException</span>
<span class="line">│  └─ SocketException</span>
<span class="line">├─ ParseException</span>
<span class="line">├─ GeneralSecurityException</span>
<span class="line">├─ SQLException</span>
<span class="line">└─ TimeoutException</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>Java中Logging模块定义了7个等级，默认是INFO</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line"> SEVERE</span>
<span class="line"> WARNING</span>
<span class="line"> INFO</span>
<span class="line"> CONFIG</span>
<span class="line"> FINE</span>
<span class="line"> FINER</span>
<span class="line"> FINES</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>Commons Logging定义了6个日志级别，默认级别是INFO。</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">FATAL</span>
<span class="line">ERROR</span>
<span class="line">WARNING</span>
<span class="line">INFO</span>
<span class="line">DEBUG</span>
<span class="line">TRACE</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>对比Commons Logging和SLF4J的接口：</li></ol><table><thead><tr><th>Commons Logging</th><th>SLF4J</th></tr></thead><tbody><tr><td>org.apache.commons.logging.Log</td><td>org.slf4j.Logger</td></tr><tr><td>org.apache.commons.logging.LogFactory</td><td>org.slf4j.LoggerFactory</td></tr><tr><td>## 7. Reflection</td><td></td></tr></tbody></table><ol><li>基础定义</li></ol><ul><li><p>反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。</p></li><li><p>反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p></li><li><p>除了int等基本类型外，Java的其他类型全部都是class（包括interface）。</p></li><li><p>class（包括interface）的本质是数据类型（Type）。无继承关系的数据类型无法赋值</p></li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">Number n = new Double(123.456); // OK\\</span>
<span class="line">String s = new Double(123.456); // compile error!\\</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。</li><li>这种通过Class实例获取class信息的方法称为反射（Reflection）。</li></ul><blockquote><p>[!Note] 每个类（class）或者基本数据类型（e.g.,int）都是一种数据类型（Type）。</p></blockquote><blockquote><p>[!Note] 其中Java为每个类（class）都创建了一个实例（Class），这个实例与其他实例不同，它的实例类型是Class类型，这个实例记录了class的完整信息。</p></blockquote><h2 id="_8-maven" tabindex="-1"><a class="header-anchor" href="#_8-maven"><span>8. Maven</span></a></h2><h3 id="_8-1-基础配置" tabindex="-1"><a class="header-anchor" href="#_8-1-基础配置"><span>8.1 基础配置</span></a></h3><ul><li>本地仓库地址路径的配置</li><li>下载包与插件时的镜像源的配置</li><li>指定javajdk版本的配置</li></ul><h3 id="_8-2-maven指令" tabindex="-1"><a class="header-anchor" href="#_8-2-maven指令"><span>8.2 Maven指令</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">mvn compile</span>
<span class="line">mvn clean</span>
<span class="line">mvn test</span>
<span class="line">mvn package</span>
<span class="line">mvn install</span>
<span class="line"></span>
<span class="line">mvn aechetype:generate</span>
<span class="line">	-DgroupId={project-packaging}</span>
<span class="line">	-DartifactId={project-name}</span>
<span class="line">	-DarchetypeArtifactId=maven-archetype-quickstart</span>
<span class="line">	-DubteractiveMode=false</span>
<span class="line"></span>
<span class="line">//创建Java工程</span>
<span class="line">mvn archetype:generate -DgroupId=com.demo -DartifactId=java-project -DarchetypeArtifactId=maven-archetype-quickstart -Dversion=0.0.1-snapshot -DinteractiveMode=false</span>
<span class="line">//创建Web工程</span>
<span class="line">mvn archetype:generate -DgroupId=com.demo -DartifactId=web-project -DarchetypeArtifactId=maven-archetype-webapp -Dversion=0.0.1-snapshot -DinteractiveMode=false</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_8-3-maven工程结构" tabindex="-1"><a class="header-anchor" href="#_8-3-maven工程结构"><span>8.3 Maven工程结构</span></a></h3><p><img src="`+i+'" alt=""><img src="'+t+'" alt=""></p><h3 id="_8-4-maven依赖范围" tabindex="-1"><a class="header-anchor" href="#_8-4-maven依赖范围"><span>8.4 Maven依赖范围</span></a></h3><p><img src="'+c+'" alt=""><img src="'+r+'" alt=""></p><h3 id="_8-5-maven主要功能" tabindex="-1"><a class="header-anchor" href="#_8-5-maven主要功能"><span>8.5 Maven主要功能</span></a></h3><ol><li>提供了一套标准化的项目结构</li><li>提供了一套标准化的构建流程（编译，测试，打包，发布）</li><li>提供了一套依赖管理机制</li></ol><h3 id="_8-6-maven模型" tabindex="-1"><a class="header-anchor" href="#_8-6-maven模型"><span>8.6 Maven模型</span></a></h3><p><img src="'+d+'" alt=""></p><h2 id="_9-spring" tabindex="-1"><a class="header-anchor" href="#_9-spring"><span>9. Spring</span></a></h2><h3 id="_9-1-spring体系结构" tabindex="-1"><a class="header-anchor" href="#_9-1-spring体系结构"><span>9.1 Spring体系结构</span></a></h3><ul><li>Spring是分层的JavaSE/EE应用full-stack轻量级开源框架，以IoC(Inverse Of Control:反转控制)和AOP(Aspect Oriented Programming:面向切面编程)为内核。</li><li><img src="'+o+'" alt=""></li></ul><h3 id="_9-2-spring的开发示例" tabindex="-1"><a class="header-anchor" href="#_9-2-spring的开发示例"><span>9.2 Spring的开发示例</span></a></h3><ol><li>开发原理 <img src="'+p+'" alt=""></li><li>开发流程 <img src="'+v+'" alt=""></li></ol><blockquote><p>[!note] 第4步，Spring配置文件通常取名为“applicationContext.xml”。</p></blockquote><blockquote><p>[!note] 配置Bean标签，参数有id，class，scope，init-method，destroy-method.</p></blockquote><ol start="3"><li><p>scope配置的意义 <img src="'+h+`" alt=""></p></li><li><p>Bean实例化的方式 - 无参构造方法 - 工厂静态方法 - 工厂实例方法</p></li></ol><h3 id="_9-3-依赖注入" tabindex="-1"><a class="header-anchor" href="#_9-3-依赖注入"><span>9.3 依赖注入</span></a></h3><ol><li>Bean的依赖注入（Dependency Injection，它是Spring框架核心IOC的具体实现）</li><li>注入方法</li></ol><ul><li><p>set方法注入</p></li><li><p>构造方法注入</p></li></ul><ol start="3"><li>注入类型</li></ol><ul><li>普通数据类型</li><li>引用注入类型</li><li>集合数据类型</li></ul><ol start="4"><li>配置文件</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">&lt;bean&gt; 标签</span>
<span class="line">	id 属性 ： 在容器中Bean实例的唯一标识，不允许重复</span>
<span class="line">	class属性：要实例化的Bean的全限定名（也叫全包名）</span>
<span class="line">	scope属性：Bean的作用范围，常用是singleton（默认）和prototype</span>
<span class="line">	&lt;property&gt;标签：属性注入</span>
<span class="line">		name属性：属性名称</span>
<span class="line">		value属性：注入的普通属性值</span>
<span class="line">		ref属性：注入的对象引用值</span>
<span class="line">		&lt;list&gt;标签</span>
<span class="line">		&lt;map&gt;标签</span>
<span class="line">		&lt;properties&gt;标签</span>
<span class="line">	&lt;constructor-arg&gt;标签</span>
<span class="line">&lt;import&gt;标签：导入其他的Spring的分文件</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-4-application-context" tabindex="-1"><a class="header-anchor" href="#_9-4-application-context"><span>9.4 Application Context</span></a></h3><p><img src="`+g+'" alt=""></p><h3 id="_9-5-注解开发" tabindex="-1"><a class="header-anchor" href="#_9-5-注解开发"><span>9.5 注解开发</span></a></h3><ol><li>原始注解 <img src="'+m+'" alt=""><img src="'+u+'" alt=""> Autowired 和 Qualifier进行set注入的时候可以不需要写set方法；使用xml配置时需要写set方法。</li><li>新注解 <img src="'+b+'" alt=""></li></ol><h3 id="_9-6-springjunit" tabindex="-1"><a class="header-anchor" href="#_9-6-springjunit"><span>9.6 SpringJunit</span></a></h3><ul><li>Spring每次测试都需要先创建容器，然后再拿到bean进行测试，否则会出现空指针。</li><li>因此 <ul><li>让SpringJunit负责创建Spring容器</li><li>将需要测试的Bean直接在测试类中进行注入</li><li></li></ul></li></ul><h2 id="_10-javaweb" tabindex="-1"><a class="header-anchor" href="#_10-javaweb"><span>10 JavaWeb</span></a></h2><h3 id="_10-1-简介" tabindex="-1"><a class="header-anchor" href="#_10-1-简介"><span>10.1 简介</span></a></h3><ol><li>关系 <img src="'+_+'" alt=""></li><li>内容 1. 数据库：MySQL，JDBC，MyBatis 2. 前端：HTML+CSS，JS，Ajax+Vue+ElementUI 3. Web核心：Tomcat+HTTP+Servlet，Request+Response，JSP，Cookie+Session，Filter+Listener</li><li>数据库查询 <img src="'+x+'" alt=""></li></ol><h3 id="_10-2-jdbc" tabindex="-1"><a class="header-anchor" href="#_10-2-jdbc"><span>10.2 JDBC</span></a></h3><ol><li>JDBC就是使用JAVA语言操作关系型数据库的一套API <img src="'+E+'" alt=""></li><li>逻辑 <img src="'+J+'" alt=""></li><li>预防SQL注入 <img src="'+y+'" alt=""></li><li>抽取<code>jdbc</code>配置文件 <img src="'+f+'" alt=""></li><li>缺点 <img src="'+j+'" alt=""></li></ol><h3 id="_10-3-数据源-连接池" tabindex="-1"><a class="header-anchor" href="#_10-3-数据源-连接池"><span>10.3 数据源（连接池）</span></a></h3><ul><li><p>常见的数据源：DBCP、C3P0、BoneCP、Druid</p></li><li><p>数据库连接池是个容器，负责分配、管理数据库连接（Connection）</p></li><li><p>数据库连接池允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</p></li><li><p>优势</p><ul><li>资源重用</li><li>提升系统相应速度</li><li>避免数据库连接遗漏</li></ul></li><li><p>数据源开发步骤：</p><ol><li>导入数据源的坐标和驱动坐标</li><li>创建数据源的对象</li><li>设置数据源的基本连接数据（账号、密码）</li><li>获取连接资源和归还连接资源</li></ol></li><li><p>图示 <img src="'+A+'" alt=""></p></li><li><p>数据库连接池的标准接口实现：DataSource</p></li><li><p>增删改查数据 <img src="'+B+'" alt=""></p></li></ul><h2 id="_11-mybatis" tabindex="-1"><a class="header-anchor" href="#_11-mybatis"><span>11 MyBatis</span></a></h2><h3 id="_11-1-mybatis是什么" tabindex="-1"><a class="header-anchor" href="#_11-1-mybatis是什么"><span>11.1 MyBatis是什么</span></a></h3><ul><li>MyBatis是一款持久层框架，用于简化JDBC开发</li><li>持久层是负责将数据保存到数据库的那一层代码</li></ul><blockquote><p>[!Note] JaveEE的三层架构：表现层、业务层、持久层</p></blockquote><h3 id="_11-2-mabatis简化" tabindex="-1"><a class="header-anchor" href="#_11-2-mabatis简化"><span>11.2 MaBatis简化</span></a></h3><ol start="6"><li>处理JDBC连接过程的硬编码问题：配置文件</li><li>处理JDBC连接过程的操作繁琐问题：自动完成</li></ol><blockquote><p>[!Summary] MyBatis免除了几乎所有的JDBC代码以及设置参数和获取结果集的工作</p></blockquote><h3 id="_11-3-mapper代理开发" tabindex="-1"><a class="header-anchor" href="#_11-3-mapper代理开发"><span>11.3 Mapper代理开发</span></a></h3><ul><li>目的 <ol><li>解决原生方式中的硬编码</li><li>简化后期执行SQL</li></ol></li><li>图示 <img src="'+F+'" alt=""></li><li>步骤要求 <img src="'+D+'" alt=""></li></ul><h3 id="_11-4-mybatis核心配置文件" tabindex="-1"><a class="header-anchor" href="#_11-4-mybatis核心配置文件"><span>11.4 MyBatis核心配置文件</span></a></h3><p><img src="'+k+'" alt=""></p>',108)]))}const N=e(S,[["render",C]]),q=JSON.parse('{"path":"/guide/knowledge/Java.html","title":"Java","lang":"zh-CN","frontmatter":{},"git":{},"filePathRelative":"guide/knowledge/Java.md"}');export{N as comp,q as data};
