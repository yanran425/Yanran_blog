import{_ as t,c as s,d as a,o as e}from"./app-O9I-yMSb.js";const o="/Yanran_blog/assets/Qt-D1h9PjfW.png",l="/Yanran_blog/assets/Qt-1-CUl6WnxP.png",c="/Yanran_blog/assets/Qt-2-yLaTkYFp.png",i="/Yanran_blog/assets/Qt-3-BDzOm-d4.png",p="/Yanran_blog/assets/Qt-4-Cn8wAOJi.png",d="/Yanran_blog/assets/Qt-5-BoxhzWQO.png",r="/Yanran_blog/assets/Qt-6-B8LLGkj-.png",u={};function h(k,n){return e(),s("div",null,n[0]||(n[0]=[a(`<h1 id="qt" tabindex="-1"><a class="header-anchor" href="#qt"><span>Qt</span></a></h1><h2 id="_1-基础介绍" tabindex="-1"><a class="header-anchor" href="#_1-基础介绍"><span>1. 基础介绍</span></a></h2><ul><li><p>Qt是一个跨平台的C++图形用户界面应用程序框架。它为应用程序开发者提供建立艺术级图形界面所需的所有功能。它是完全面向对象的，很容易扩展，并且允许真正的组件编程。</p></li><li><p>1991 奇趣科技</p></li><li><p>MFC不是跨平台的</p></li><li><p>优势</p><ol><li>跨平台，几乎支持所有的平台</li><li>接口简单，容易上手，学习QT框架对学习其他框架有参考意义。</li><li>一定程度上简化了内存回收机制</li><li>开发效率高，能够快速的构建应用程序。</li><li>有很好的社区氛围，市场份额在缓慢上升。</li><li>可以进行嵌入式开发。</li></ol></li><li><p>成功案例</p><ol><li>Linux桌面环境KDE</li><li>WPS Office 办公软件</li><li>Skype 网络电话</li><li>Google Earth 谷歌地图</li><li>VLC多媒体播放器</li><li>VirtualBox虚拟机软件</li></ol></li></ul><h2 id="_2-框架说明" tabindex="-1"><a class="header-anchor" href="#_2-框架说明"><span>2. 框架说明</span></a></h2><h3 id="_2-1-窗口类" tabindex="-1"><a class="header-anchor" href="#_2-1-窗口类"><span>2.1 窗口类</span></a></h3><ul><li>窗口共有3种基类</li></ul><ol><li>QWidget</li><li>QMainWindow</li><li>QDialog</li></ol><blockquote><p>[!NOTE] 其实QWidget是父类。QMainWindow和QDialog均继承于QWidget。</p></blockquote><ul><li><p>自定义的窗口类继承于上述三大类，其中<code>Q_OBJECT</code>是一个宏，申明后表示该窗口类可以使用<strong>信号和槽的机制</strong>。</p></li><li><p>main函数<code>main(int argc char *argv[])</code>是程序项目的入口，第二个参数是一个指针数组。main函数里实例化一个应用程序对象和窗口对象，将应用程序对象挂入消息循环机制，窗口对象进行显示。</p></li><li><p>QApplication：包含一个应用程序类的头文件，在Qt中，应用程序对象有且仅有一个。</p></li><li><p><code>a.exec()</code>是让应用程序对象（有且仅有1个）进入消息循环机制中，让代码阻塞到当前行。</p></li><li></li></ul><h3 id="_2-3-工程文件" tabindex="-1"><a class="header-anchor" href="#_2-3-工程文件"><span>2.3 工程文件</span></a></h3><ul><li>.pro文件</li><li>Qt包含的模块</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">QT       += core gui</span>
<span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th style="text-align:center;">模块</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">Qt Core</td><td style="text-align:left;">下面其他模块使用的核心基础类（Qt Core是非图形模块）。</td></tr><tr><td style="text-align:center;">Qt D-Bus</td><td style="text-align:left;">用于通过 D-Bus 协议进行进程间通信的类。</td></tr><tr><td style="text-align:center;">Qt GUI</td><td style="text-align:left;">图形用户界面 （GUI） 组件的基类。</td></tr><tr><td style="text-align:center;">Qt Network</td><td style="text-align:left;">使网络编程更轻松、更易移植的类。</td></tr><tr><td style="text-align:center;">Qt QML</td><td style="text-align:left;">QML 和 JavaScript 语言的类。</td></tr><tr><td style="text-align:center;">Qt Quick</td><td style="text-align:left;">一个声明性框架，用于构建具有自定义用户界面的高度动态的应用程序。</td></tr><tr><td style="text-align:center;">Qt Quick Controls</td><td style="text-align:left;">提供轻量级 QML 类，用于为桌面、嵌入式和移动设备创建高性能用户界面。这些类型采用简单的样式体系结构，并且非常高效。</td></tr><tr><td style="text-align:center;">Qt Quick Dialogs</td><td style="text-align:left;">用于从 Qt 快速应用程序创建系统对话框并与之交互的类。</td></tr><tr><td style="text-align:center;">Qt Quick Layouts</td><td style="text-align:left;">布局是用于在用户界面中排列基于 Qt Quick 2 的项目的项。</td></tr><tr><td style="text-align:center;">Qt Quick Test QML</td><td style="text-align:left;">应用程序的单元测试框架，其中测试用例编写为 JavaScript 函数。</td></tr><tr><td style="text-align:center;">Qt Test</td><td style="text-align:left;">用于单元测试 Qt 应用程序和库的类。</td></tr><tr><td style="text-align:center;">Qt Widgets</td><td style="text-align:left;">使用C++ widget扩展Qt GUI的类。</td></tr></tbody></table><ul><li>模板变量：告诉qmake为这个应用程序生成哪种makefile。下面是可供使用的选择：<strong>TEMPLATE</strong> = app</li></ul><table><thead><tr><th style="text-align:center;">类型</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">app</td><td style="text-align:left;">建立一个应用程序的makefile。这是默认值，所以如果模板没有被指定，这个将被使用。</td></tr><tr><td style="text-align:center;">lib</td><td style="text-align:left;">建立一个库的makefile。</td></tr><tr><td style="text-align:center;">vcapp</td><td style="text-align:left;">建立一个应用程序的VisualStudio项目文件。</td></tr><tr><td style="text-align:center;">vclib</td><td style="text-align:left;">建立一个库的VisualStudio项目文件。</td></tr><tr><td style="text-align:center;">subdirs</td><td style="text-align:left;">这是一个特殊的模板，它可以创建一个能够进入特定目录并且为一个项目文件生成makefile并且为它调用make的makefile。</td></tr></tbody></table><ul><li><p>指定生成的应用程序名：<strong>TARGET</strong> = QtDemo</p></li><li><p>工程中包含的头文件/源文件/ui文件/资源文件：</p></li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">SOURCES += \\</span>
<span class="line">    main.cpp \\</span>
<span class="line">    mywidget.cpp</span>
<span class="line"></span>
<span class="line">HEADERS += \\</span>
<span class="line">    mywidget.h</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>配置信息：CONFIG用来告诉qmake关于应用程序的配置信息。</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">CONFIG += c++17</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="_3-对象树" tabindex="-1"><a class="header-anchor" href="#_3-对象树"><span>3. 对象树</span></a></h2><ul><li>控件的基类也是窗口类，需要严格指定各个窗口间的关系。</li><li>QObject是以对象树的形式组织起来的。</li><li>当创建一个QObject对象时，QObject的构造函数接收一个QObject指针作为参数，这个参数就是 parent，也就是父对象指针，指向其父对象，创建的这个QObject对象会自动添加到其父对象的children()列表。当父对象析构的时候，这个列表中的所有对象也会被析构。（注意，这里的父对象并不是继承意义上的父类！）</li><li>当创建的对象在堆区时候，如果指定的父亲是QObject派生下来的类或者QObject子类派生下来的类，可以不用管理释放的操作，将对象会放入到对象树中。一定程度上简化了内存回收机制。</li></ul><p><img src="`+o+`" alt="600"></p><ul><li><p>QWidget是能够在屏幕上显示的一切组件的父类。QWidget继承自QObject，因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件。因此，它会显示在父组件的坐标系统中，被父组件的边界剪裁。例如，当用户关闭一个对话框的时候，应用程序将其删除，那么，我们希望属于这个对话框的按钮、图标等应该一起被删除。事实就是如此，因为这些都是对话框的子组件。我们也可以自己删除子对象，它们会自动从其父对象列表中删除。比如，当我们删除了一个工具栏时，其所在的主窗口会自动将该工具栏从其子对象列表中删除，并且自动调整屏幕显示。</p></li><li><p>当一个QObject对象在堆上创建的时候，Qt 会同时为其创建一个对象树。不过，对象树中对象的顺序是没有定义的。这意味着，销毁这些对象的顺序也是未定义的。任何对象树中的 QObject对象 delete 的时候，如果这个对象有 parent，则自动将其从 parent 的children() 列表中删除；如果有孩子，则自动 delete 每一个孩子。Qt 保证没有QObject会被 delete 两次，这是由析构顺序决定的。</p></li><li><p>如果QObject在栈上创建，Qt 保持同样的行为。正常情况下，这也不会发生什么问题。</p></li></ul><blockquote><p>[!NOTE] 声明的变量名会依次存入一个栈中，当超出作用域的时候最后一个创建的对象会先被作为析构对象，析构时找其parent，在其parent的children()列表中移除该对象，接着对该对象的children()列表中的对象析构，最后析构该对象自身。至此该对象析构完成，接着弹出栈中下一个要被析构的对象，重复执行，这个栈只是记录变量名称的，相当于索引。</p></blockquote><blockquote><p>[!NOTE] 非控件或窗口的类的对象也可以设置父对象，其也可以被Qt托管析构。</p></blockquote><h2 id="_4-窗口坐标体系" tabindex="-1"><a class="header-anchor" href="#_4-窗口坐标体系"><span>4. 窗口坐标体系</span></a></h2><ul><li>以左上角为原点（0,0），X向右增加，Y向下增加。</li><li>对于嵌套窗口，其坐标是相对于父窗口来说的。</li></ul><h2 id="_5-信号和槽" tabindex="-1"><a class="header-anchor" href="#_5-信号和槽"><span>5. 信号和槽</span></a></h2><h3 id="_5-1-原理" tabindex="-1"><a class="header-anchor" href="#_5-1-原理"><span>5.1 原理</span></a></h3><ul><li><p>信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。<strong>当某个事件发生之后</strong>，比如，按钮检测到自己被点击了一下，<strong>它就会发出一个信号（signal）</strong>。这种发出是没有目的的，类似广播。<strong>如果有对象对这个信号感兴趣，它就会使用连接（connect）函数</strong>，意思是，<strong>将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号</strong>。也就是说，<strong>当信号发出时，被连接的槽函数会自动被回调</strong>。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。</p></li><li><p>信号槽的优点：松散耦合。信号发送端和接收端本来是没有关联的，通过connect连接将两端耦合在了一起。</p></li><li><p>connect()函数最常用的一般形式：connect(sender, signal, receiver, slot);</p><ol><li>sender：发出信号的对象</li><li>signal：发送对象发出的信号</li><li>receiver：接收信号的对象</li><li>slot：接收对象在接收到信号之后所需要调用的函数（槽函数）</li></ol></li></ul><blockquote><p>[!NOTE] 控件或者是窗口对象可以有一些被触发的事件，触发这些事件就会发出相应的信号，大多数情况下事件和消息合并处理统一为消息；接收方监听到指定消息后执行相应的槽函数。</p></blockquote><h3 id="_5-2-自定义信号和槽" tabindex="-1"><a class="header-anchor" href="#_5-2-自定义信号和槽"><span>5.2 自定义信号和槽</span></a></h3><ul><li><p>自定义信号：</p><ol><li>写到signals下</li><li>返回值只能是void</li><li>只需要声明，不需要实现</li><li>可以有参数，可以重载</li><li>发送者必须是QObject的子类</li></ol></li><li><p>自定义槽函数</p><ol><li>可以写到public下当作正常的函数（槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响）</li><li>返回值只能是void</li><li>需要声明，也需要实现</li><li>可以有参数，可以重载</li><li>接收者如果是成员函数，那么其对应的类必须是QObject的子类</li><li>任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数</li></ol></li><li><p>手动触发自定义信号</p><ol><li>触发自定义信号要用 <code>emit</code>，eg. emit tea-&gt;hungry();</li></ol></li><li><p>连接信号和槽</p><ol><li>使用connect()函数连接信号和槽。</li><li>信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致</li><li>如果信号和槽的参数不一致，允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少）。</li><li>一个信号可以和多个槽相连，如果是这种情况，这些槽会一个接一个的被调用，但是它们的<strong>调用顺序是不确定的</strong>。</li><li>多个信号可以连接到一个槽<strong>只要任意一个信号发出，这个槽就会被调用</strong>。</li><li>一个信号可以连接到另外的一个信号，当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。</li></ol></li><li><p>信号和槽重载</p><ol><li>信号和槽重载时，需要用函数指针指向确定的信号和槽。同时在connect函数中填写新的指针参数。</li></ol></li><li><p>断开信号和槽</p><ol><li>使用disconnect()函数断开信号和槽，参数和connect的一样。</li><li>槽可以被取消链接，这种情况并不经常出现，因为<strong>当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽</strong>。</li></ol></li></ul><blockquote><p>[!NOTE] 目标是希望发送者发出信号，监听者接收信号并执行相应的槽函数。期间也可以实现信号连接信号，槽函数内部再发起新的信号。本质是由于信号与槽都是函数，都能写入connect函数中。</p></blockquote><h3 id="_5-3-lambda表达式" tabindex="-1"><a class="header-anchor" href="#_5-3-lambda表达式"><span>5.3 Lambda表达式</span></a></h3><ul><li>使用Lambda表达式设置槽函数可以实现槽函数获取其他来源的数据做参数。</li></ul><div class="language-C line-numbers-mode" data-highlighter="prismjs" data-ext="C"><pre><code class="language-C"><span class="line">//Lambda表达式(实现slot的参数比signal的参数多）</span>
<span class="line">QPushButton * btn6 = new QPushButton(&quot;Lambda&quot;, this);</span>
<span class="line">btn6-&gt;move(400,200);</span>
<span class="line">connect(btn6, &amp;QPushButton::clicked, [btn6](QString foodName=&quot;wy&quot;)</span>
<span class="line">	{btn6-&gt;setText(foodName);}</span>
<span class="line">);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-4-总结" tabindex="-1"><a class="header-anchor" href="#_5-4-总结"><span>5.4 总结</span></a></h3><ul><li>如果槽函数无需明确接收方对象，则可以省略接收方对象这个参数。所以在Lambda表达式中大多数情况下都可以省略第三个参数。</li></ul><p><img src="`+l+'" alt="600"></p><h2 id="_6-qmainwindow" tabindex="-1"><a class="header-anchor" href="#_6-qmainwindow"><span>6. QMainWindow</span></a></h2><h3 id="_6-1-简介" tabindex="-1"><a class="header-anchor" href="#_6-1-简介"><span>6.1 简介</span></a></h3><ul><li>QMainWindow是一个为用户提供主窗口程序的类，包含一个菜单栏（menu bar）、多个工具栏(tool bars)、多个锚接部件/浮动窗口(dock widgets)、一个状态栏(status bar)及一个中心部件(central widget)，是许多应用程序的基础，如文本编辑器，图片编辑器等。</li></ul><p><img src="'+c+'" alt="600"></p><h3 id="_6-2-常见栏目" tabindex="-1"><a class="header-anchor" href="#_6-2-常见栏目"><span>6.2 常见栏目</span></a></h3><ul><li>菜单栏最多只能有1个，创建时不能new QMenuBar，要使用其约束的单例创建方法 MenuBar()。状态栏，中心部件同样最多只能有1个。</li><li>各控件均需要绑定到主窗口上。</li><li>菜单栏可以加子菜单栏，Action，分割线等</li><li>工具栏可以加Action，按钮等Widget子类控件。</li><li>状态栏可以加Label等Widget子类。</li><li>铆接部件本身就是Widget子类。</li></ul><h2 id="_7-资源文件" tabindex="-1"><a class="header-anchor" href="#_7-资源文件"><span>7. 资源文件</span></a></h2><ul><li>Qt添加资源文件需要先创建资源板块，会生成xxx.qrc的资源文件板块，然后在该资源文件板块中添加资源文件并设置其前缀。</li><li>使用Qt资源 <ol><li>“:+前缀名+文件名”</li><li>绝对路径</li><li>在UI界面中图形化选择</li></ol></li><li>在代码中使用Action时用ui-&gt;xxxAction即可索引到。</li></ul><h2 id="_8-对话框" tabindex="-1"><a class="header-anchor" href="#_8-对话框"><span>8. 对话框</span></a></h2><h3 id="_8-1-qmessagebox" tabindex="-1"><a class="header-anchor" href="#_8-1-qmessagebox"><span>8.1 QMessageBox</span></a></h3><ul><li>Qt已经封装好的对话框QMessageBox <ol><li>QMessageBox::critical（错误对话框）</li><li>QMessageBox::information（消息对话框）</li><li>QMessageBox::question（提问对话框）</li><li>QMessageBox::warning（警告对话框）</li></ol></li></ul><blockquote><p>[!Note] QMessageBox类有静态成员函数，直接使用静态成员函数就可以创建对话框，创建的对话框都是模态对话框，并且自动show，无需再调用exec或者show</p></blockquote><h3 id="_8-2-自定义对话框" tabindex="-1"><a class="header-anchor" href="#_8-2-自定义对话框"><span>8.2 自定义对话框</span></a></h3><ul><li>自定义对话框：QDialog <ol><li>模态对话框（dlg.exec();），有阻塞功能 <ol><li>可以创建在栈区</li><li>调用exec()函数实现阻塞</li></ol></li><li>非模态对话框 <ol><li>需要建立在堆区保持住</li><li>设置属性为关闭即释放，否则可能存在内存泄漏</li><li>调用show()展示窗口</li></ol></li></ol></li></ul><h3 id="_8-3-标准对话框" tabindex="-1"><a class="header-anchor" href="#_8-3-标准对话框"><span>8.3 标准对话框</span></a></h3><ul><li>Qt已经内置好的 <ol><li>QColorDialog：选择颜色</li><li>QFileDialog：选择文件</li><li>QFontDialog：选择字体</li><li>QInputDialog：允许用户输入一个值，并将其值返回</li><li>QMessageBox：消息对话框</li><li>QProgressDialog：显示操作过程</li></ol></li></ul><h2 id="_9-控件及使用" tabindex="-1"><a class="header-anchor" href="#_9-控件及使用"><span>9. 控件及使用</span></a></h2><h3 id="_9-1-布局" tabindex="-1"><a class="header-anchor" href="#_9-1-布局"><span>9.1 布局</span></a></h3><ol><li>利用容器组合控件（可省略，但是为了便于控制还是组合起来再布局更好）</li><li>容器内垂直水平网格布局</li><li>巧用弹簧</li></ol><h3 id="_9-2-按钮" tabindex="-1"><a class="header-anchor" href="#_9-2-按钮"><span>9.2 按钮</span></a></h3><ol><li>普通按钮</li><li>工具按钮（带icon）</li><li>单项选择按钮</li><li>多项选择按钮</li></ol><h3 id="_9-3-复合控件" tabindex="-1"><a class="header-anchor" href="#_9-3-复合控件"><span>9.3 复合控件</span></a></h3><ol><li>列表</li><li>树结构</li><li>表格</li></ol><h3 id="_9-4-组合控件-容器" tabindex="-1"><a class="header-anchor" href="#_9-4-组合控件-容器"><span>9.4 组合控件（容器）</span></a></h3><ol><li>组盒子</li><li>滚动区域</li><li>折叠组</li><li>标签组</li><li>翻页（栈）组</li><li>边框</li><li>浮动窗口</li></ol><h3 id="_9-5-输入控件" tabindex="-1"><a class="header-anchor" href="#_9-5-输入控件"><span>9.5 输入控件</span></a></h3><ol><li>下拉框</li><li>字体下拉框</li><li>单行输入框</li><li>文本输入框（支持加粗倾斜字体颜色等设置）</li><li>纯文本输入框（不支持加粗倾斜字体颜色等设置）</li><li>加减器</li><li>小数加减器</li><li>时间选择框</li><li>日期选择框</li><li>水平/垂直滚动条</li><li>进度条</li></ol><h3 id="_9-6-显示控件" tabindex="-1"><a class="header-anchor" href="#_9-6-显示控件"><span>9.6 显示控件</span></a></h3><ol><li>Label（也可以显示图片、动图）</li><li>浏览器文本</li><li>图像展示</li><li>日历展示</li><li>时刻展示</li><li>进度展示</li></ol><h3 id="_9-7-自定义控件" tabindex="-1"><a class="header-anchor" href="#_9-7-自定义控件"><span>9.7 自定义控件</span></a></h3><ul><li>自定义控件时要选“从类设计图形”，则会生成相应的UI和C++类，类中可以提供一些对外的功能函数。</li><li>主窗口想要使用自定义控件（类），则新建目标控件的UI对象（通常为Widget）,接着将该对象提升为目标控件的类。</li></ul><h2 id="_10-事件" tabindex="-1"><a class="header-anchor" href="#_10-事件"><span>10. 事件</span></a></h2><h3 id="_10-1-鼠标事件" tabindex="-1"><a class="header-anchor" href="#_10-1-鼠标事件"><span>10.1 鼠标事件</span></a></h3><ul><li>事件：QEvent，有很多枚举值</li><li>鼠标事件是事件中常用的一类</li><li>当要对控件添加一些默认的（构造和析构）或者被动触发的事件函数时，需要自己重定义一个类（基类与控件的基类相同），然后将控件提升为新建的类，接着在自己新建的类中可以重写很多方法或添加新方法。</li><li>鼠标的信息都记录在了QMouseEvent类中。</li><li>鼠标进入指定范围：enterEvent()；鼠标离开指定范围：leaveEvent()；</li><li>mousePressEvent()，mouseReleaseEvent()，mouseMoveEvent()</li><li>其中mouseMoveEvent函数是当鼠标被追踪时才会检测，例如可能是按键摁下才开始追踪。即默认追踪状态是false，要想时刻追踪移动，需要设置为true。this-&gt;setMouseTracking(true);</li></ul><h3 id="_10-2-定时器" tabindex="-1"><a class="header-anchor" href="#_10-2-定时器"><span>10.2 定时器</span></a></h3><ul><li>定时器的目标是：每隔多久发送一次某个信号</li><li>事件的方式 <ol><li>定时器本质是利用的事件，重写timerEvent(QTimerEvent *event)函数，参数event自动已经读取到了消息机制中的所有事件和信号，其中每个计时器都有一个timeId唯一标识，event可以区分不同的计时器。</li><li>在构造函数中构造并启动定时器startTimer(1000)，时间单位是毫秒。返回值是int，可以作为该计时器的timeId。</li></ol></li><li>类的方式 <ol><li>QTimer是一个定时器的类，调用其对象实例timer的start(500)方法即可启动定时器，实现的效果是该对象实例每0.5s发送一个信号。</li><li>紧接着用connect对信号进行处理即可。</li><li>当有多个定时器的时候再创建新的QTimer对象即可。</li></ol></li></ul><h3 id="_10-3-qt事件" tabindex="-1"><a class="header-anchor" href="#_10-3-qt事件"><span>10.3 Qt事件</span></a></h3><ul><li>事件主要分为两种：</li></ul><ol><li>在与用户交互时发生。比如按下鼠标（<em>mousePressEvent</em>），敲击键盘（<em>keyPressEvent</em>）等。</li><li>系统自动发生，比如计时器事件（<em>timerEvent</em>）等。</li></ol><ul><li><p>在发生事件时（比如说上面说的按下鼠标），就会产生一个_QEvent_对象（这里是_[QMouseEvent]，为_QEvent_的子类），这个_QEvent_对象会传给当前组件的_event_函数。如果当前组件没有安装<strong>事件过滤器</strong>，则会被_event_函数发放到相应的_xxxEvent_函数中（这里是_mousePressEvent_函数）。</p></li><li><p>当系统产生QEvent对象时，就会传入相应类的event函数并调用。函数的返回值是bool类型，返回值不同有不同的意义。</p></li><li><p>如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false。如果返回值是 true，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。</p></li><li><p>这个函数<code>event()</code>不处理事件本身；根据交付的事件类型，它为该特定类型的事件调用具体的事件处理程序，并根据事件是被接受还是被忽略发送响应。</p></li><li><p>Qt系统在处理事件时，有一种机制叫<strong>事件传播机制</strong>。也就是说，在子组件（比如说一个_QButton_）中发生的事件，调用了子组件的_event_函数之后，还会调用父组件（比如说_QWidget_）的_event_函数。_event_函数的返回值就用于控制这样的一个过程。</p></li></ul><blockquote><p>[!NOTE] 应用程序接收到事件后并不是直接调用相应的执行函数，而是先将事件对象扔给event函数进行事件分发。这个event函数接收的参数是QEvent类型的对象，返回值是bool类型。如果返回true，则说明该分发器已经把这个事件处理了（<strong>这里其实就可以人为的重写分发器函数实现拦截事件和直接处理事件</strong>），如果是false，则说明没处理，得把参数这个对象转发给具体操作的事件处理程序并调用。</p></blockquote><h3 id="_10-4-事件分发器" tabindex="-1"><a class="header-anchor" href="#_10-4-事件分发器"><span>10.4 事件分发器</span></a></h3><ul><li><p>一般来说，我们定义的类继承常用的Widget或者Label类，重写event函数时写自己要监听的事件的逻辑，不关注的事件交给父类（常用的Widget或者Label类）的默认event事件处理，否则会导致自己定义的类只能监听自己想要的事件。</p></li><li><p>e.type()可以判断是什么类型的事件</p></li><li><p>Qt 程序需要在main()函数创建一个QApplication对象，然后调用它的exec()函数。这个函数就是开始 Qt 的事件循环。在执行exec()函数之后，程序将进入事件循环来监听应用程序的事件。当事件发生时，Qt 将创建一个事件对象。</p></li><li><p>Qt 中所有事件类都继承于QEvent。在事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数（event handler）。</p></li><li><p>event()函数主要用于事件的分发。所以，如果你希望在事件分发之前做一些操作，就可以重写这个event()函数了。例如，我们希望在一个QWidget组件中监听 tab 键的按下，那么就可以继承QWidget，并重写它的event()函数，来达到这个目的。</p></li><li><p><img src="'+i+`" alt="800"></p></li></ul><h3 id="_10-5-事件过滤器" tabindex="-1"><a class="header-anchor" href="#_10-5-事件过滤器"><span>10.5 事件过滤器</span></a></h3><ul><li><p>在程序将事件分发到事件分类器前，利用过滤器做拦截。</p></li><li><p>某些应用场景下，需要拦截某个组件发生的事件，让这个事件不再向其他组件进行传播，这时候可以为这个组件或其父组件安装一个事件过滤器（<em>evenFilter</em>）。</p></li><li><p>evenFilter函数有两个参数，一个为具体发生事件的组件，一个为发生的事件（产生的_QEvent_对象）。当事件是我们感兴趣的类型，可以就地进行处理，并令其不再转发给其他组件。函数的返回值也是bool类型，作用跟_even_函数类似，返回true为不再转发，false则让其继续被处理。</p></li><li><p>实际使用中，我们需要对QObject组件调用_installEvenFilter_函数，即为组件安装过滤器，才能使用事件过滤器这个机制。这样，该组件及其子组件的事件就会被监听。这个机制的好处在于不用像重写QEvent和xxxEvent函数一样需要继承Qt的内置类。</p></li><li><p>同事件分发器一样，不过滤的事件抛给父类处理</p></li></ul><div class="language-C line-numbers-mode" data-highlighter="prismjs" data-ext="C"><pre><code class="language-C"><span class="line">//安装事件过滤器</span>
<span class="line">ui-&gt;label_6-&gt;installEventFilter(this);</span>
<span class="line">//重写过滤器事件</span>
<span class="line">bool myMainWindow::eventFilter(QObject *watched, QEvent *event){...}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><img src="`+p+'" alt="800"></li></ul><h2 id="_11-绘图" tabindex="-1"><a class="header-anchor" href="#_11-绘图"><span>11. 绘图</span></a></h2><h3 id="_11-1-绘图事件" tabindex="-1"><a class="header-anchor" href="#_11-1-绘图事件"><span>11.1 绘图事件</span></a></h3><ul><li>绘图事件其实是默认执行的，eventFilter没有过滤掉，event函数分发事件到paintEvent()并调用，只不过这个函数默认是空，所以相当于不绘图，要想绘图直接重写该函数即可。</li><li>过程 <ol><li>先初始化一个画家类QPainter painter(this);this指的是当前类的图形区域，即绘图设备。</li><li>设置画笔：QPen pen(QPen pen(QColor(255,0,0),3,Qt::DashLine); painter.setPen(pen);</li><li>设置抗锯齿能力：painter.setRenderHint(QPainter::Antialiasing);</li><li>移动画家的位置：painter.translate(100,100);</li><li>保存和恢复画家的位置：painter.restore(); painter.restore();</li><li>设置画刷：QBrush brush(Qt::green, Qt::Dense4Pattern); painter.setBrush(brush);</li><li>绘制图形：painter.drawLine，painter.drawEllipse，painter.drawRect</li><li>绘制字：painter.drawText</li><li>绘制资源图片：painter.drawPixmap(-90, 1,QPixmap(&quot;:/pic/Image/LuffyQ.png&quot;));</li></ol></li><li><img src="'+d+`" alt=""></li><li>Qt 的绘图系统实际上是，使用QPainter在QPainterDevice上进行绘制，它们之间使用QPaintEngine进行通讯（也就是翻译QPainter的指令）。</li></ul><h3 id="_11-2-手动调用绘图事件" tabindex="-1"><a class="header-anchor" href="#_11-2-手动调用绘图事件"><span>11.2 手动调用绘图事件</span></a></h3><ul><li>重新调用绘图事件，并不能直接显示的调用paintEvent函数，因为它需要参数，必须是事件触发的，而不是显示逻辑调用。</li><li>重新调用绘图事件，应该使用update()或者repaint()，该函数会重新调用paintEvent函数。</li></ul><h3 id="_11-3-绘图设备" tabindex="-1"><a class="header-anchor" href="#_11-3-绘图设备"><span>11.3 绘图设备</span></a></h3><ul><li>绘图设备是指继承QPaintDevice的子类。常用的是四个这样的类，分别是QPixmap、QBitmap、QImage和 QPicture。其中， <ol><li>QPixmap专门为图像在屏幕上的显示做了优化</li><li>QBitmap是QPixmap的一个子类，它的色深限定为1，可以使用 QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap。</li><li>QImage专门为图像的像素级访问做了优化。可以修改像素点img.setPixel(i,j,value)</li><li>QPicture可以记录和重现QPainter的各条命令。用于记绘图指令。</li></ol></li><li>绘图设备相当于一张纸，决定了画在哪个纸上，QWidget的父类是QObject and QPaintDevice。</li><li>可以新建一个QPixmap的绘图设备，在其上绘制后保存至本地。</li><li>可以在QWidget绘图设备上绘制QPixmap绘图设备，类似于纸叠纸</li></ul><h2 id="_12-文件" tabindex="-1"><a class="header-anchor" href="#_12-文件"><span>12. 文件</span></a></h2><h3 id="_12-1-文件读写" tabindex="-1"><a class="header-anchor" href="#_12-1-文件读写"><span>12.1 文件读写</span></a></h3><ul><li>文件读取对话框：QString path = QFileDialog::getOpenFileName(this,&quot;打开文件&quot;,&quot;./&quot;);</li><li>读过程 <ol><li>创建文件对象：QFile file(path);</li><li>设置打开方式：file.open(QIODevice::ReadOnly);</li><li>读取内容：QByteArray array = file.readAll();，这里读到的是QByteArray；QByteArray array2; while(!file.atEnd()){array += file.readLine();}读的也是QByteArray</li><li>输出内容：注意编码格式转换</li><li>关闭文件对象：file.close();</li></ol></li><li>写过程 <ol><li>创建文件对象：QFile file(path);</li><li>设置打开方式：file.open(QIODevice::Append);</li><li>写入内容：file.write(&quot;aaaaaaaaa&quot;);</li><li>关闭文件对象：file.close();</li></ol></li></ul><h3 id="_12-2-文件信息" tabindex="-1"><a class="header-anchor" href="#_12-2-文件信息"><span>12.2 文件信息</span></a></h3><ul><li>文件信息类：QFileInfo</li><li>过程 <ol><li>创建文件信息对象：QFileInfo info(path);</li><li>获取其信息：info.size()&lt;&lt;info.suffix()&lt;&lt;info.fileName()&lt;&lt;info.filePath()&lt;&lt;info.birthTime()&lt;&lt;info.lastModified();，size输出的是字节的大小,data返回的是QDateTime。</li><li>输出内容：qDebug()&lt;&lt;info.birthTime().toString(&quot;yyyy/MMdd hh:mm:ss&quot;)&lt;&lt;info.lastModified();，注意格式转换</li></ol></li></ul><h2 id="_13-核心类" tabindex="-1"><a class="header-anchor" href="#_13-核心类"><span>13. 核心类</span></a></h2><h3 id="_13-1-基础数据类型" tabindex="-1"><a class="header-anchor" href="#_13-1-基础数据类型"><span>13.1 基础数据类型</span></a></h3><table><thead><tr><th><strong>C++ 类型</strong></th><th><strong>Qt 对应类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>bool</code></td><td><code>bool</code></td><td>完全兼容，Qt 中无替代类型。</td></tr><tr><td><code>char</code></td><td><code>char</code></td><td>8 位字符，完全兼容。</td></tr><tr><td><code>wchar_t</code></td><td>通常使用 <code>QChar</code></td><td><code>QChar</code> 是 16 位 Unicode 字符，替代 <code>wchar_t</code> 处理国际化文本。</td></tr><tr><td><code>int</code>/<code>long</code></td><td><code>int</code>/<code>qint32</code>/<code>qlonglong</code></td><td><code>qint32</code> 等类型保证跨平台长度一致（如 <code>qint64</code> 始终为 64 位）。</td></tr><tr><td><code>float</code>/<code>double</code></td><td><code>float</code>/<code>double</code></td><td>完全兼容，Qt 中无替代类型。</td></tr><tr><td><code>void*</code></td><td><code>QVariant</code></td><td><code>QVariant</code> 是类型安全的通用容器，可存储多种数据类型（类似 <code>std::any</code>）。</td></tr></tbody></table><h3 id="_13-2-预处理与宏" tabindex="-1"><a class="header-anchor" href="#_13-2-预处理与宏"><span>13.2 预处理与宏</span></a></h3><table><thead><tr><th><strong>C++ 特性</strong></th><th><strong>Qt 对应特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>#define</code></td><td>Qt 特定宏</td><td>Qt 使用宏实现信号槽、元对象系统（如 <code>Q_OBJECT</code>、<code>SIGNAL()</code>、<code>SLOT()</code>）。</td></tr><tr><td><code>assert()</code></td><td><code>Q_ASSERT()</code></td><td>Qt 的断言宏，支持调试模式下的条件检查。</td></tr><tr><td><code>__FILE__</code>/<code>__LINE__</code></td><td><code>Q_FUNC_INFO</code></td><td><code>Q_FUNC_INFO</code> 提供函数名、文件名和行号信息。</td></tr></tbody></table><h3 id="_13-3-面向对象特性" tabindex="-1"><a class="header-anchor" href="#_13-3-面向对象特性"><span>13.3 面向对象特性</span></a></h3><table><thead><tr><th><strong>C++ 特性</strong></th><th><strong>Qt 对应特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>继承与多态</td><td>Qt 类继承体系</td><td>Qt 类通常继承自 <code>QObject</code>，支持信号槽和元对象系统。</td></tr><tr><td>虚函数</td><td>正常使用</td><td>Qt 类可使用 C++ 虚函数机制，同时信号槽基于元对象系统实现动态绑定。</td></tr><tr><td>抽象类</td><td>正常使用</td><td>Qt 支持纯虚函数定义抽象接口。</td></tr></tbody></table><h3 id="_13-4-模板与泛型编程" tabindex="-1"><a class="header-anchor" href="#_13-4-模板与泛型编程"><span>13.4 模板与泛型编程</span></a></h3><table><thead><tr><th><strong>C++ 特性</strong></th><th><strong>Qt 对应特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>模板类 / 函数</td><td>Qt 模板类</td><td>Qt 提供了大量模板类（如 <code>QVector&lt;T&gt;</code>、<code>QMap&lt;K,V&gt;</code>），用法与 STL 类似。</td></tr><tr><td><code>std::function</code></td><td><code>std::function</code> 或 <code>QtConcurrent</code></td><td>Qt 提供 <code>QtConcurrent</code> 处理异步任务，也可直接使用 C++11 的 <code>std::function</code>。</td></tr><tr><td><code>lambda</code> 表达式</td><td>完全支持</td><td>Qt 5+ 支持 C++11 lambda，可用于信号槽连接（如 <code>connect(sender, &amp;Sender::signal, [=](){...})</code>）。</td></tr></tbody></table><h3 id="_13-5-容器类" tabindex="-1"><a class="header-anchor" href="#_13-5-容器类"><span>13.5 容器类</span></a></h3><table><thead><tr><th><strong>STL 类型</strong></th><th><strong>Qt 对应类</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><code>std::vector&lt;T&gt;</code></td><td><code>QVector&lt;T&gt;</code></td><td>动态数组，连续内存存储，性能优于 <code>QList</code>（但插入删除效率低）。</td></tr><tr><td><code>std::deque&lt;T&gt;</code></td><td><code>QList&lt;T&gt;</code> 或 <code>QQueue&lt;T&gt;</code></td><td><code>QQueue</code> 是 <code>QList</code> 的子类，提供队列接口（<code>enqueue</code>/<code>dequeue</code>）。</td></tr><tr><td><code>std::list&lt;T&gt;</code></td><td><code>QList&lt;T&gt;</code></td><td>双向链表（Qt 5 及以前），Qt 6 起改为连续存储（类似 <code>QVector</code>）。</td></tr><tr><td><code>std::stack&lt;T&gt;</code></td><td><code>QStack&lt;T&gt;</code></td><td>栈结构，LIFO（后进先出），基于 <code>QVector</code> 实现。</td></tr><tr><td><code>std::queue&lt;T&gt;</code></td><td><code>QQueue&lt;T&gt;</code></td><td>队列结构，FIFO（先进先出），基于 <code>QList</code> 实现。</td></tr><tr><td><code>std::set&lt;T&gt;</code></td><td><code>QSet&lt;T&gt;</code></td><td>无序集合，基于哈希表实现，查找效率高（平均 O (1)）。</td></tr><tr><td><code>std::map&lt;K, V&gt;</code></td><td><code>QMap&lt;K, V&gt;</code></td><td>有序映射（按键排序），基于红黑树实现，插入 / 查找效率 O (log n)。</td></tr><tr><td><code>std::unordered_map</code></td><td><code>QHash&lt;K, V&gt;</code></td><td>无序映射，基于哈希表实现，查找效率更高（平均 O (1)）。</td></tr></tbody></table><ul><li>std::deque是一种动态数组与链表结合的混合数据结构,<code>deque</code>维护一个<strong>中控器（通常是指针数组）</strong>，它存储了所有块的地址。中控器本身是动态扩展的，当块数量超过中控器容量时，会重新分配更大的中控器。</li><li>std::stack和std::queue默认底层容器是<code>std::deque</code>（双端队列）</li><li>Qt中没有QDeque</li><li>QStack是基于QVector实现</li><li>QQueue是基于QList实现</li></ul><h3 id="_13-6-字符串处理" tabindex="-1"><a class="header-anchor" href="#_13-6-字符串处理"><span>13.6 字符串处理</span></a></h3><table><thead><tr><th><strong>STL 类型</strong></th><th><strong>Qt 对应类</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><code>std::string</code></td><td><code>QString</code></td><td>Unicode 字符串，支持国际化、正则表达式、编码转换（如 UTF-8/16）。</td></tr><tr><td><code>std::wstring</code></td><td><code>QString</code></td><td><code>QString</code> 使用 16 位 Unicode 存储，兼容宽字符需求。</td></tr><tr><td><code>std::stringstream</code></td><td><code>QStringBuilder</code></td><td>高效字符串拼接（使用 <code>%</code> 操作符），或 <code>QString::arg()</code> 格式化。</td></tr><tr><td><code>std::regex</code></td><td><code>QRegularExpression</code></td><td>Qt 的正则表达式类，功能更强大，性能更优（基于 PCRE）。</td></tr></tbody></table><h3 id="_13-7-文件与-io" tabindex="-1"><a class="header-anchor" href="#_13-7-文件与-io"><span>13.7 文件与 IO</span></a></h3><table><thead><tr><th><strong>STL 类型</strong></th><th><strong>Qt 对应类</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><code>std::fstream</code></td><td><code>QFile</code> + <code>QTextStream</code></td><td>文件读写，支持跨平台路径处理、权限控制、文本 / 二进制模式。</td></tr><tr><td><code>std::cout</code>/<code>std::cin</code></td><td><code>QTextStream</code></td><td>控制台输入输出，支持 Unicode 和更灵活的格式化。</td></tr><tr><td><code>std::ifstream</code></td><td><code>QFile</code> + <code>QTextStream</code></td><td>读取文件（文本模式）。</td></tr><tr><td><code>std::ofstream</code></td><td><code>QFile</code> + <code>QTextStream</code></td><td>写入文件（文本模式）。</td></tr><tr><td>文件路径处理</td><td><code>QDir</code>/<code>QFileInfo</code></td><td>Qt 提供跨平台的文件路径处理，自动处理不同操作系统的路径分隔符。</td></tr></tbody></table><h3 id="_13-8-智能指针" tabindex="-1"><a class="header-anchor" href="#_13-8-智能指针"><span>13.8 智能指针</span></a></h3><table><thead><tr><th><strong>STL 类型</strong></th><th><strong>Qt 对应类</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><code>std::unique_ptr&lt;T&gt;</code></td><td><code>QScopedPointer&lt;T&gt;</code></td><td>独占所有权的智能指针，对象销毁时自动释放内存。</td></tr><tr><td><code>std::shared_ptr&lt;T&gt;</code></td><td><code>QSharedPointer&lt;T&gt;</code></td><td>共享所有权的智能指针，通过引用计数管理内存。</td></tr><tr><td><code>std::weak_ptr&lt;T&gt;</code></td><td><code>QWeakPointer&lt;T&gt;</code></td><td>弱引用，不控制对象生命周期，用于解决循环引用问题。</td></tr></tbody></table><h3 id="_13-9-日期与时间" tabindex="-1"><a class="header-anchor" href="#_13-9-日期与时间"><span>13.9 日期与时间</span></a></h3><table><thead><tr><th><strong>STL 类型</strong></th><th><strong>Qt 对应类</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><code>std::chrono</code></td><td><code>QDateTime</code>/<code>QTime</code></td><td>日期时间处理，支持时区转换、格式化输出、计时器功能。</td></tr><tr><td><code>std::time_t</code></td><td><code>QDateTime::toTime_t()</code></td><td>与 Unix 时间戳互转。</td></tr></tbody></table><h3 id="_13-10-并发与多线程" tabindex="-1"><a class="header-anchor" href="#_13-10-并发与多线程"><span>13.10 并发与多线程</span></a></h3><table><thead><tr><th><strong>C++ 特性</strong></th><th><strong>Qt 对应特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>std::thread</code></td><td><code>QThread</code></td><td><code>QThread</code> 提供更高级的线程管理（如信号槽、事件循环）。</td></tr><tr><td><code>std::mutex</code></td><td><code>QMutex</code></td><td><code>QMutex</code> 支持递归锁和超时机制，功能更丰富。</td></tr><tr><td><code>std::condition_variable</code></td><td><code>QWaitCondition</code></td><td>与 <code>QMutex</code> 配合使用，实现线程间同步。</td></tr><tr><td><code>std::atomic</code></td><td><code>QAtomicInteger</code></td><td>Qt 的原子操作类，提供平台无关的原子操作。</td></tr><tr><td><code>std::future</code></td><td><code>QFuture</code></td><td><code>QFuture</code> 与 <code>QtConcurrent</code> 配合，处理异步计算结果。</td></tr></tbody></table><h3 id="_13-11-网络编程" tabindex="-1"><a class="header-anchor" href="#_13-11-网络编程"><span>13.11 网络编程</span></a></h3><table><thead><tr><th><strong>STL 类型</strong></th><th><strong>Qt 对应类</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><code>std::socket</code></td><td><code>QTcpSocket</code>/<code>QUdpSocket</code></td><td>跨平台 TCP/UDP 通信，基于事件驱动，支持异步操作。</td></tr><tr><td><code>std::url</code> (C++20)</td><td><code>QUrl</code></td><td>URL 解析与操作，支持编码转换、URL 参数处理。</td></tr><tr><td>原始 socket API</td><td><code>QTcpSocket</code>/<code>QTcpServer</code>/<code>QUdpSocket</code></td><td>Qt 提供高层封装，支持异步通信和事件驱动编程。</td></tr><tr><td>HTTP 客户端</td><td><code>QNetworkAccessManager</code></td><td>支持 HTTP/HTTPS 请求，处理 Cookie、SSL 等。</td></tr><tr><td>WebSocket</td><td><code>QWebSocket</code></td><td>Qt 5.3+ 提供的 WebSocket 协议实现。</td></tr></tbody></table><h3 id="_13-12-异常处理" tabindex="-1"><a class="header-anchor" href="#_13-12-异常处理"><span>13.12 异常处理</span></a></h3><table><thead><tr><th><strong>C++ 特性</strong></th><th><strong>Qt 对应特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>try/catch</code></td><td>完全支持</td><td>Qt 代码可正常使用 C++ 异常处理机制，但 Qt 自身很少抛出异常（更倾向返回错误码）。</td></tr><tr><td><code>std::exception</code></td><td>完全支持</td><td>Qt 代码可抛出和捕获标准异常，或自定义异常类。</td></tr></tbody></table><h3 id="_13-13-内存管理" tabindex="-1"><a class="header-anchor" href="#_13-13-内存管理"><span>13.13 内存管理</span></a></h3><table><thead><tr><th><strong>C++ 特性</strong></th><th><strong>Qt 对应特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>new</code>/<code>delete</code></td><td>正常使用</td><td>Qt 对象可手动管理内存，也可通过父对象自动管理（如 <code>QObject</code> 的父子关系）。</td></tr><tr><td>智能指针 (<code>std::unique_ptr</code>, <code>std::shared_ptr</code>)</td><td><code>QScopedPointer</code>, <code>QSharedPointer</code></td><td>Qt 提供类似智能指针，与 Qt 对象的生命周期管理更兼容。</td></tr><tr><td>对象树</td><td>Qt 特有机制</td><td>Qt 对象通过父子关系形成对象树，父对象销毁时自动销毁所有子对象。</td></tr></tbody></table><h3 id="_13-14-元编程与反射" tabindex="-1"><a class="header-anchor" href="#_13-14-元编程与反射"><span>13.14 元编程与反射</span></a></h3><table><thead><tr><th><strong>C++ 特性</strong></th><th><strong>Qt 对应特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>编译时元编程 (模板元)</td><td>较少使用</td><td>Qt 主要通过元对象系统（而非模板元）实现运行时反射。</td></tr><tr><td>反射机制</td><td>Qt 元对象系统</td><td>通过 <code>Q_OBJECT</code> 宏和 <code>QMetaObject</code> 类，支持运行时类型信息、属性访问和信号槽。</td></tr><tr><td>RTTI (<code>typeid</code>, <code>dynamic_cast</code>)</td><td>正常使用</td><td>Qt 类可使用 C++ RTTI，但元对象系统提供更强大的类型信息。</td></tr></tbody></table><h3 id="_13-15-gui-与用户界面" tabindex="-1"><a class="header-anchor" href="#_13-15-gui-与用户界面"><span>13.15 GUI 与用户界面</span></a></h3><table><thead><tr><th><strong>C++ 特性</strong></th><th><strong>Qt 对应特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>无（C++ 标准无 GUI）</td><td>Qt Widgets 或 Qt Quick</td><td>Qt Widgets 提供传统桌面控件，Qt Quick 基于 QML 实现现代 UI 设计。</td></tr><tr><td>事件循环</td><td><code>QCoreApplication::exec()</code></td><td>Qt 应用程序的核心，处理窗口事件、定时器等。</td></tr><tr><td>信号与回调</td><td>Qt 信号槽机制</td><td>比 C++ 回调函数更灵活，支持类型安全的跨线程通信。</td></tr></tbody></table><h3 id="_13-16-国际化与本地化" tabindex="-1"><a class="header-anchor" href="#_13-16-国际化与本地化"><span>13.16 国际化与本地化</span></a></h3><table><thead><tr><th><strong>C++ 特性</strong></th><th><strong>Qt 对应特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>无标准方案</td><td><code>QString</code> + <code>Qt Linguist</code></td><td><code>QString</code> 存储 Unicode 文本，<code>Qt Linguist</code> 工具生成翻译文件（.ts/.qm）。</td></tr><tr><td>字符串编码转换</td><td><code>QTextCodec</code></td><td>处理不同字符编码间的转换（如 UTF-8、GBK、Latin1 等）。</td></tr></tbody></table><h2 id="_14-其他类" tabindex="-1"><a class="header-anchor" href="#_14-其他类"><span>14. 其他类</span></a></h2><h3 id="_14-1-qprocess" tabindex="-1"><a class="header-anchor" href="#_14-1-qprocess"><span>14.1 QProcess</span></a></h3><p><code>QProcess</code> 是 Qt 中管理外部进程的核心类，封装了进程启动、通信、终止等功能，常用方法如下：</p><table><thead><tr><th>分类</th><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><strong>进程启动</strong></td><td><code>start(const QString &amp;program)</code></td><td>启动指定程序（program 为可执行文件路径）</td></tr><tr><td></td><td><code>startDetached(...)</code></td><td>启动独立进程（与主进程脱离关联）</td></tr><tr><td><strong>数据发送</strong></td><td><code>write(const QByteArray &amp;data)</code></td><td>向子进程的标准输入写入数据</td></tr><tr><td><strong>数据接收</strong></td><td><code>readAllStandardOutput()</code></td><td>读取子进程的标准输出数据</td></tr><tr><td></td><td><code>readAllStandardError()</code></td><td>读取子进程的错误输出数据</td></tr><tr><td><strong>进程控制</strong></td><td><code>terminate()</code></td><td>发送终止信号（温和终止，允许清理资源）</td></tr><tr><td></td><td><code>kill()</code></td><td>强制终止进程（立即结束，可能丢失数据）</td></tr><tr><td></td><td><code>waitForFinished(int msecs)</code></td><td>等待进程结束（超时时间 msecs，-1 为无限等）</td></tr><tr><td><strong>状态查询</strong></td><td><code>isOpen()</code></td><td>判断进程是否启动并处于运行状态</td></tr><tr><td></td><td><code>state()</code></td><td>返回进程状态（NotRunning/Starting/Running）</td></tr><tr><td><strong>信号</strong></td><td><code>readyReadStandardOutput()</code></td><td>子进程有标准输出时触发</td></tr><tr><td></td><td><code>readyReadStandardError()</code></td><td>子进程有错误输出时触发</td></tr><tr><td></td><td><code>finished(int exitCode)</code></td><td>子进程结束时触发</td></tr></tbody></table><h3 id="_14-2-动画" tabindex="-1"><a class="header-anchor" href="#_14-2-动画"><span>14.2 动画</span></a></h3><ul><li>QPropertyAnimation</li></ul><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code class="language-cpp"><span class="line">QPropertyAnimation <span class="token operator">*</span>animation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">QPropertyAnimation</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">&quot;geometry&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">animation<span class="token operator">-&gt;</span><span class="token function">setDuration</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">animation<span class="token operator">-&gt;</span><span class="token function">setStartValue</span><span class="token punctuation">(</span><span class="token function">QRect</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">animation<span class="token operator">-&gt;</span><span class="token function">setEndValue</span><span class="token punctuation">(</span><span class="token function">QRect</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">animation<span class="token operator">-&gt;</span><span class="token function">setEasingCurve</span><span class="token punctuation">(</span>QEasingCurve<span class="token double-colon punctuation">::</span>OutCurve<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">animation<span class="token operator">-&gt;</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_14-3-音效" tabindex="-1"><a class="header-anchor" href="#_14-3-音效"><span>14.3 音效</span></a></h3><ul><li>QSound</li><li>需要包含新的模块multimedia</li></ul><div class="language-C line-numbers-mode" data-highlighter="prismjs" data-ext="C"><pre><code class="language-C"><span class="line">QSoundEffect *startSound = new QSoundEffect(this);</span>
<span class="line">startSound-&gt;setSource(QUrl::fromLocalFile(&quot;:/res/TapButtonSound.wav&quot;));</span>
<span class="line">startSound-&gt;play();</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>可以设置循环播放的次数，设为-1表示一直循环。</li></ul><h3 id="_14-4-qtextedit" tabindex="-1"><a class="header-anchor" href="#_14-4-qtextedit"><span>14.4 QTextEdit</span></a></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>QTextEdit</strong></th><th><strong>QPlainTextEdit</strong></th></tr></thead><tbody><tr><td><strong>设计定位</strong></td><td>富文本编辑器（支持 HTML 格式）</td><td>纯文本编辑器（高效处理大文本）</td></tr><tr><td><strong>性能</strong></td><td>较慢（处理复杂格式）</td><td>较快（专注纯文本，优化大文件性能）</td></tr><tr><td><strong>默认行为</strong></td><td>支持换行（Wrap）</td><td>默认不换行（需手动设置 <code>setLineWrapMode</code>）</td></tr><tr><td><strong>文本格式</strong></td><td>支持 HTML 标签（如 <code>&lt;b&gt;</code>, <code>&lt;a&gt;</code>）、表格、图片等</td><td>仅支持纯文本（无格式）</td></tr><tr><td><strong>适用场景</strong></td><td>文档编辑器、聊天窗口（需显示富文本）</td><td>代码编辑器、日志查看器（大文本、无格式需求）</td></tr><tr><td><strong>常用 API</strong></td><td><code>setHtml()</code>, <code>insertHtml()</code></td><td><code>setPlainText()</code>, <code>appendPlainText()</code></td></tr></tbody></table><h3 id="_14-5-qconcurrent" tabindex="-1"><a class="header-anchor" href="#_14-5-qconcurrent"><span>14.5 QConcurrent</span></a></h3><p>在 Qt 项目中，<code>#include &lt;QtConcurrent/QtConcurrent&gt;</code> 引入的是 <strong>QtConcurrent 模块</strong>，它提供了一组高级 API，用于简化<strong>并行编程</strong>（多线程任务），让开发者无需手动管理线程池和低级线程同步细节。</p><h4 id="_14-5-1-qtconcurrent-模块的核心功能" tabindex="-1"><a class="header-anchor" href="#_14-5-1-qtconcurrent-模块的核心功能"><span>14.5.1 QtConcurrent 模块的核心功能</span></a></h4><p>QtConcurrent 模块提供了三种主要的并行编程模式：</p><ol><li><code>QtConcurrent::run()</code></li></ol><ul><li>功能：在后台线程执行函数或成员函数，返回 <code>QFuture</code> 对象用于跟踪结果。</li><li>示例：<div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code class="language-cpp"><span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;QtConcurrent/QtConcurrent&gt;</span></span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 普通函数</span></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">calculateSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 在后台线程执行</span></span>
<span class="line">QFuture<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> future <span class="token operator">=</span> <span class="token class-name">QtConcurrent</span><span class="token double-colon punctuation">::</span><span class="token function">run</span><span class="token punctuation">(</span>calculateSum<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 获取结果（阻塞当前线程，直到完成）</span></span>
<span class="line"><span class="token keyword">int</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><ol start="2"><li>并行算法</li></ol><ul><li>功能：对容器（如 <code>QList</code>、<code>QVector</code>）中的元素并行执行操作，包括： <ul><li><code>QtConcurrent::map()</code>：对每个元素应用函数。</li><li><code>QtConcurrent::filter()</code>：筛选符合条件的元素。</li><li><code>QtConcurrent::reduce()</code>：合并元素结果。</li></ul></li><li>示例：<div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code class="language-cpp"><span class="line">QList<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> numbers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 并行计算每个元素的平方</span></span>
<span class="line">QFuture<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span> future <span class="token operator">=</span> <span class="token class-name">QtConcurrent</span><span class="token double-colon punctuation">::</span><span class="token function">map</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    num <span class="token operator">=</span> num <span class="token operator">*</span> num<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">future<span class="token punctuation">.</span><span class="token function">waitForFinished</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待所有任务完成</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><ol start="3"><li><code>QtConcurrent::mappedReduced()</code></li></ol><ul><li><p>功能：结合映射（map）和归约（reduce）操作，先并行处理元素，再合并结果。</p></li><li><p>示例：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code class="language-cpp"><span class="line">QList<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> numbers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 并行计算总和</span></span>
<span class="line">QFuture<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> future <span class="token operator">=</span> <span class="token class-name">QtConcurrent</span><span class="token double-colon punctuation">::</span><span class="token function">mappedReduced</span><span class="token punctuation">(</span></span>
<span class="line">    numbers<span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> num <span class="token operator">*</span> num<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 映射函数：计算平方</span></span>
<span class="line">    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> result<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> result <span class="token operator">+=</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 归约函数：累加结果</span></span>
<span class="line">    QtConcurrent<span class="token double-colon punctuation">::</span>UnorderedReduce <span class="token comment">// 归约顺序无关</span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">int</span> sum <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取最终总和</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="_14-5-2-qfuture-与-qfuturewatcher" tabindex="-1"><a class="header-anchor" href="#_14-5-2-qfuture-与-qfuturewatcher"><span>14.5.2 QFuture 与 QFutureWatcher</span></a></h4><ul><li><strong><code>QFuture</code></strong>：表示异步操作的结果，提供查询状态（如 <code>isFinished()</code>）、获取结果（如 <code>result()</code>）等功能。</li><li><strong><code>QFutureWatcher</code></strong>：用于监视 <code>QFuture</code> 的进度，支持信号槽机制，适合与 UI 交互。<div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code class="language-cpp"><span class="line">QFuture<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> future <span class="token operator">=</span> <span class="token class-name">QtConcurrent</span><span class="token double-colon punctuation">::</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">QFutureWatcher<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">*</span> watcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">QFutureWatcher</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 连接信号，任务完成时触发</span></span>
<span class="line"><span class="token function">connect</span><span class="token punctuation">(</span>watcher<span class="token punctuation">,</span> <span class="token operator">&amp;</span>QFutureWatcher<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>finished<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>MyClass<span class="token double-colon punctuation">::</span>handleFinished<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">watcher<span class="token operator">-&gt;</span><span class="token function">setFuture</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置要监视的 future</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="_14-5-3-使用场景" tabindex="-1"><a class="header-anchor" href="#_14-5-3-使用场景"><span>14.5.3 使用场景</span></a></h4><p>QtConcurrent 适用于以下场景：</p><ul><li><strong>耗时操作</strong>：如文件读写、网络请求、复杂计算，避免阻塞主线程（UI 线程）。</li><li><strong>数据并行</strong>：对大量数据进行并行处理（如图像 / 视频处理、科学计算）。</li><li><strong>任务并行</strong>：同时执行多个独立任务（如多文件压缩、多 API 调用）。</li></ul><h4 id="_14-5-4-与手动管理线程的对比" tabindex="-1"><a class="header-anchor" href="#_14-5-4-与手动管理线程的对比"><span>14.5.4 与手动管理线程的对比</span></a></h4><table><thead><tr><th><strong>特性</strong></th><th><strong>QtConcurrent</strong></th><th><strong>手动管理线程（QThread）</strong></th></tr></thead><tbody><tr><td><strong>复杂度</strong></td><td>低（高级 API，无需管理线程池）</td><td>高（需手动创建 / 销毁线程，处理同步）</td></tr><tr><td><strong>适用场景</strong></td><td>简单并行任务（如函数调用、容器处理）</td><td>复杂长时间任务（如持续网络监听）</td></tr><tr><td><strong>与 UI 交互</strong></td><td>友好（通过 <code>QFutureWatcher</code> 和信号槽）</td><td>需谨慎（避免直接在子线程操作 UI）</td></tr><tr><td><strong>资源控制</strong></td><td>自动管理线程池，优化资源使用</td><td>需手动调整线程数量，可能导致资源浪费</td></tr></tbody></table><h2 id="_15-字符串转换" tabindex="-1"><a class="header-anchor" href="#_15-字符串转换"><span>15. 字符串转换</span></a></h2><table><thead><tr><th>类型</th><th>所属语言 / 库</th><th>编码方式</th><th>内存管理方式</th><th>特点与用途</th></tr></thead><tbody><tr><td>C 风格字符串</td><td>C/C++</td><td>依赖系统（如 ASCII、GBK）</td><td>手动管理（<code>char*</code>）</td><td>以<code>\\0</code>结尾的字符数组，用于与 C 库交互，低级别操作（如网络编程）。</td></tr><tr><td><code>std::string</code></td><td>C++ STL</td><td>依赖系统（通常与 C 风格一致）</td><td>自动管理</td><td>C++ 标准字符串，支持动态扩展，提供丰富 API（如<code>substr</code>、<code>find</code>），适合常规使用。</td></tr><tr><td><code>std::wstring</code></td><td>C++ STL</td><td>UTF-16（Windows）或 UTF-32（Linux）</td><td>自动管理</td><td>宽字符字符串，用于 Unicode 编码，解决多语言显示问题（如中文、日文）。</td></tr><tr><td><code>CString</code></td><td>MFC/ATL</td><td>多字节或 Unicode（取决于项目配置）</td><td>自动管理</td><td>MFC 框架的字符串类，主要用于 Windows 桌面应用开发，兼容 MFC 组件。</td></tr><tr><td><code>QString</code></td><td>Qt</td><td>Unicode（UTF-16 内部存储）</td><td>自动管理</td><td>Qt 框架的字符串类，跨平台支持，提供丰富的文本处理功能（如正则表达式、国际化）。</td></tr><tr><td><code>QByteArray</code></td><td>Qt</td><td>原始字节流（无编码限制）</td><td>自动管理</td><td>用于存储原始二进制数据或文本，适合网络通信、文件操作等场景。</td></tr></tbody></table><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code class="language-cpp"><span class="line"><span class="token comment">// std::string → char*</span></span>
<span class="line">std<span class="token double-colon punctuation">::</span>string str <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> c_str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 返回const char*，指向内部数据</span></span>
<span class="line"><span class="token keyword">char</span><span class="token operator">*</span> non_const_str <span class="token operator">=</span> <span class="token operator">&amp;</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment">// C++11及以后支持，需确保字符串非空</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// char* → std::string</span></span>
<span class="line"><span class="token keyword">char</span><span class="token operator">*</span> c_str <span class="token operator">=</span> <span class="token string">&quot;World&quot;</span><span class="token punctuation">;</span></span>
<span class="line">std<span class="token double-colon punctuation">::</span>string <span class="token function">str</span><span class="token punctuation">(</span>c_str<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 直接构造</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 需要使用codecvt或Windows API（不同平台实现不同）</span></span>
<span class="line"><span class="token comment">// 示例：Windows平台</span></span>
<span class="line"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;windows.h&gt;</span></span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// std::string → std::wstring</span></span>
<span class="line">std<span class="token double-colon punctuation">::</span>wstring <span class="token function">StringToWString</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">MultiByteToWideChar</span><span class="token punctuation">(</span>CP_UTF8<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    std<span class="token double-colon punctuation">::</span>wstring <span class="token function">wstr</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">MultiByteToWideChar</span><span class="token punctuation">(</span>CP_UTF8<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wstr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span> wstr<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// std::wstring → std::string</span></span>
<span class="line">std<span class="token double-colon punctuation">::</span>string <span class="token function">WStringToString</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>wstring<span class="token operator">&amp;</span> wstr<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">WideCharToMultiByte</span><span class="token punctuation">(</span>CP_UTF8<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> wstr<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    std<span class="token double-colon punctuation">::</span>string <span class="token function">str</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">WideCharToMultiByte</span><span class="token punctuation">(</span>CP_UTF8<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> wstr<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span> str<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// QString ↔ std::string</span></span>
<span class="line">QString qstr <span class="token operator">=</span> <span class="token class-name">QString</span><span class="token double-colon punctuation">::</span><span class="token function">fromStdString</span><span class="token punctuation">(</span>std_str<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">std<span class="token double-colon punctuation">::</span>string std_str <span class="token operator">=</span> qstr<span class="token punctuation">.</span><span class="token function">toStdString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// QString ↔ std::wstring</span></span>
<span class="line">QString qstr <span class="token operator">=</span> <span class="token class-name">QString</span><span class="token double-colon punctuation">::</span><span class="token function">fromStdWString</span><span class="token punctuation">(</span>wstr<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">std<span class="token double-colon punctuation">::</span>wstring wstr <span class="token operator">=</span> qstr<span class="token punctuation">.</span><span class="token function">toStdWString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// QString ↔ char*</span></span>
<span class="line">QString qstr <span class="token operator">=</span> <span class="token class-name">QString</span><span class="token double-colon punctuation">::</span><span class="token function">fromUtf8</span><span class="token punctuation">(</span>c_str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 从UTF-8编码的char*转换</span></span>
<span class="line"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> c_str <span class="token operator">=</span> qstr<span class="token punctuation">.</span><span class="token function">toUtf8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 转换为UTF-8编码的char*</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// QString ↔ QByteArray</span></span>
<span class="line">QString qstr <span class="token operator">=</span> <span class="token string">&quot;文本&quot;</span><span class="token punctuation">;</span></span>
<span class="line">QByteArray byteArray <span class="token operator">=</span> qstr<span class="token punctuation">.</span><span class="token function">toUtf8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 转换为UTF-8字节流</span></span>
<span class="line">QString qstr2 <span class="token operator">=</span> <span class="token class-name">QString</span><span class="token double-colon punctuation">::</span><span class="token function">fromUtf8</span><span class="token punctuation">(</span>byteArray<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从字节流恢复</span></span>
<span class="line">QByteArray byteArray <span class="token operator">=</span> qstr<span class="token punctuation">.</span><span class="token function">toLocal8Bit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//转换为本地编码（如 Windows 的 GBK）。</span></span>
<span class="line">QString qstr3 <span class="token operator">=</span> <span class="token class-name">QString</span><span class="token double-colon punctuation">::</span><span class="token function">fromLocal8Bit</span><span class="token punctuation">(</span>byteArray<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//从本地编码转换</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// QByteArray ↔ char*</span></span>
<span class="line">QByteArray <span class="token function">byteArray</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> c_str <span class="token operator">=</span> byteArray<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 直接获取内部指针</span></span>
<span class="line">QByteArray byteArray <span class="token operator">=</span> <span class="token class-name">QByteArray</span><span class="token double-colon punctuation">::</span><span class="token function">fromRawData</span><span class="token punctuation">(</span>c_str<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从char*创建,size表示数据的字节数，而非字符串长度。\`strlen(c_str)\` 会在第一个 \`\\0\` 处截断</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// QByteArray ↔ std::string</span></span>
<span class="line">std<span class="token double-colon punctuation">::</span>string str <span class="token operator">=</span> byteArray<span class="token punctuation">.</span><span class="token function">toStdString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">QByteArray byteArray <span class="token operator">=</span> <span class="token class-name">QByteArray</span><span class="token double-colon punctuation">::</span><span class="token function">fromStdString</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// CString ↔ std::string</span></span>
<span class="line">CString <span class="token function">cstr</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">std<span class="token double-colon punctuation">::</span>string std_str <span class="token operator">=</span> <span class="token function">CT2A</span><span class="token punctuation">(</span>cstr<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 需要包含 &lt;atlconv.h&gt;</span></span>
<span class="line">CString <span class="token function">cstr</span><span class="token punctuation">(</span>std_str<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// CString ↔ std::wstring</span></span>
<span class="line">CStringW <span class="token function">cstr</span><span class="token punctuation">(</span>L<span class="token string">&quot;World&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">std<span class="token double-colon punctuation">::</span>wstring wstr <span class="token operator">=</span> cstr<span class="token punctuation">.</span><span class="token function">GetBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">CStringW <span class="token function">cstr</span><span class="token punctuation">(</span>wstr<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>std::string::c_str()</code> 返回的指针仅在字符串对象有效时可用，不要保存该指针。</li><li><code>QByteArray::data()</code> 同理，避免在 <code>QByteArray</code> 销毁后使用其指针。</li><li><code>QByteArray</code> 可以存储任意字节（包括 <code>\\0</code>），但 <code>QByteArray::data()</code> 返回的 C 风格字符串会在第一个 <code>\\0</code> 处截断。</li><li>若需完整数据（含 <code>\\0</code>），用 <code>QByteArray::constData()</code> 或 <code>QByteArray::size()</code>。</li></ul><p><a href="https://blog.csdn.net/humanking7/article/details/80913474" target="_blank" rel="noopener noreferrer">[QT]QByteArray与char、int、float(及其数组)之间的互相转化_qbytearray转char数组-CSDN博客</a></p><p><a href="https://blog.csdn.net/delphigbg/article/details/128074322" target="_blank" rel="noopener noreferrer">Qt基础开发之QString与QByteArray详细用法与区别及QString QByteArray互转-CSDN博客</a></p><p><a href="https://blog.csdn.net/superrunner_wujin/article/details/103950512" target="_blank" rel="noopener noreferrer">QT char*,char[],QString,string互相转换-CSDN博客</a></p><table><thead><tr><th>数据类型</th><th>是否包含 <code>\\0</code></th><th><code>size</code> 的值</th><th>示例</th></tr></thead><tbody><tr><td>C 风格字符串</td><td>否</td><td><code>strlen(c_str)</code></td><td><code>const char* s = &quot;Hello&quot;;</code> <br><code>QByteArray::fromRawData(s, strlen(s));</code></td></tr><tr><td>二进制数据</td><td>是（若 <code>\\0</code> 是有效数据）</td><td><code>sizeof(data)</code> 或手动指定字节数</td><td><code>char data[] = { &#39;A&#39;, &#39;\\0&#39;, &#39;B&#39; }</code>;<br><code>QByteArray::fromRawData(data, 3);</code></td></tr><tr><td>带 <code>\\0</code> 的字符串</td><td>是</td><td>手动指定完整长度</td><td><code>const char* s = &quot;Hello\\0World&quot;;</code> <br><code>QByteArray::fromRawData(s, 11);</code></td></tr></tbody></table><h2 id="_16-qt事件的更深理解" tabindex="-1"><a class="header-anchor" href="#_16-qt事件的更深理解"><span>16. Qt事件的更深理解</span></a></h2><ul><li>Qt平台将系统产生的消息转变成Qt事件</li></ul><ol><li>Qt事件是一个QEvent（或子类）的对象。一个事件就是一个对象</li><li>有时一个事件包含多个事件类型，比如鼠标事件又可.以分为鼠标按下、双击、和移动多种操作</li><li>事件类型由QEvent类的枚举型QEvent::Type来表示，可由帮助文档进行查询</li><li>Qt事件用于描述程序内部或外部发生的对应动作（描述的是操作系统发生来的消息，一个系统消息对应着一个消息事件）</li><li>任意QObject对象都具备时间处理的能力</li></ol><h2 id="_17-gui应用程序的事件处理流程" tabindex="-1"><a class="header-anchor" href="#_17-gui应用程序的事件处理流程"><span>17. GUI应用程序的事件处理流程</span></a></h2><ol><li>Qt事件产生后会立即被分发到QWidget对象（QObject的子类，如按键QPushButton对象等）</li><li>QWidget对象其内部会有一个event(QEVent*)函数被调用，进行事件处理</li><li>event()根据事件类型调用不同的事件处理函数（默认的子函数）</li><li>在事件处理函数中发送Qt中预定义的信号</li><li>调用信号关联的槽函数</li></ol><ul><li>举个例子说明</li></ul><p><img src="`+r+`" alt="700"></p><ol><li>用户用鼠标点击按钮（或通过其他输入设备模拟点击）。</li><li>操作系统将 “点击事件” 封装为系统级消息（如 Windows 的 <code>WM_LBUTTONUP</code>），转发给正在运行的 Qt 应用程序（<code>QApplication</code>）。</li><li><code>QApplication</code> 将系统级事件（如 <code>WM_LBUTTONUP</code>）转换为 Qt 框架的统一事件对象（<code>QEvent</code> 或其子类，如 <code>QMouseEvent</code>）。</li><li><code>QApplication</code> 的事件循环通过 <code>notify()</code> 方法，将事件分发给窗口，这也是Qt事件分发的入口。</li><li>窗口通过事件传播机制（即调用自身的<code>event</code>函数），确定这个事件要传递给目标控件（<code>QPushButton</code>）</li><li>把事件传递给QPushButton。</li><li><code>QPushButton</code>调用 <code>QPushButton::event(QEvent* e)</code>。<code>event()</code> 函数统一处理各类事件（鼠标、键盘、绘制等）。<code>event()</code> 会根据事件类型（如 <code>QEvent::MouseButtonRelease</code>），调用对应的具体事件处理函数（如 <code>mouseReleaseEvent()</code>）。</li><li>在 <code>mouseReleaseEvent()</code> 中，Qt 内部逻辑会调用 <code>click()</code> 函数，标记按钮为 “被点击” 状态。</li><li><code>click()</code> 不仅处理视觉反馈（如按钮按下动画），还会触发信号发射（<code>clicked()</code>）的逻辑。</li><li><code>QPushButton</code> 继承自 <code>QObject</code>，通过 <code>clicked()</code> 信号通知所有关联的槽函数。</li><li>与 <code>clicked()</code> 信号关联的槽函数（如 <code>onButtonClicked()</code>）被调用，执行用户的业务逻辑。</li></ol><h2 id="_18-qt事件处理的五个层次" tabindex="-1"><a class="header-anchor" href="#_18-qt事件处理的五个层次"><span>18. Qt事件处理的五个层次</span></a></h2><ol><li>重写paintEvent()、mousePressEvent()等事件处理函数。这是最普通、最简单的形式，同时功能也最简单。</li><li>重写event()函数。event()函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数。</li><li>在特定对象上面安装事件过滤器。该过滤器仅过滤该对象接收到的事件。</li><li>在QCoreApplication::instance()上面安装事件过滤器。该过滤器将过滤所有对象的所有事件，因此和notify()函数一样强大，但是它更灵活，因为可以安装多个过滤器。全局的事件过滤器可以看到 disabled 组件上面发出的鼠标事件。全局过滤器有一个问题：只能用在主线程。</li><li>重写QCoreApplication::notify()函数。这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程的限制。但是全局范围内只能有一个被使用（因为QCoreApplication是单例的）。</li></ol><h2 id="_19-qobject三大职责" tabindex="-1"><a class="header-anchor" href="#_19-qobject三大职责"><span>19. QObject三大职责</span></a></h2><ol><li>内存管理</li><li>内省(intropection)</li><li>事件处理机制</li></ol><h2 id="_20-事件和信号对比" tabindex="-1"><a class="header-anchor" href="#_20-事件和信号对比"><span>20. 事件和信号对比</span></a></h2><blockquote><p>[!NOTE] 先有事件（QEvent），再有信号（SIGNAL）</p></blockquote><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">事件（QEvent）</th><th style="text-align:center;">信号（SIGNAL）</th></tr></thead><tbody><tr><td style="text-align:center;">与QObject的关系</td><td style="text-align:center;">由具体对象进行处理</td><td style="text-align:center;">由具体对象主动产生</td></tr><tr><td style="text-align:center;">对程序影响</td><td style="text-align:center;">改写事件处理函数可能导致程序行为发生改变</td><td style="text-align:center;">信号是否存在对应的槽函数不会改变程序行为</td></tr><tr><td style="text-align:center;">两者的联系</td><td style="text-align:center;">一般而言，信号在具体的事件处理函数中产生</td><td style="text-align:center;"></td></tr></tbody></table><ol><li>Qt中的事件和信号不同</li><li>事件由QObject对象进行处理</li><li>信号由QObject对象触发</li><li>重写事件处理函数可能改变程序行为</li><li>信号的触发不会对程序行为造成影响</li><li>事件处理是在实际工程开发中应用非常普遍的</li></ol><h2 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项"><span>注意事项</span></a></h2><ul><li>控件穿透</li><li>label设置图标文字动画都可以直接setMovie，setPixmap</li><li>pressEvent和click的先后</li><li>切换widget时状态栏不切换</li><li>button需要设置icon的大小，Label不需要设置pixmap的大小</li><li>Qt动画顺序</li><li>在实现多线程C/S通信时，有一个bug卡了我好久——当有一个C端关闭时，S端会崩溃。我通过类QList和迭代器来存储、访问C端链接的socket，而我在deleteSocket中delete迭代器后还想要访问到它，导致了内存的异常访问，使程序崩溃了。所以把delete *iter改成(*iter)-&gt;deleteLater(); 既可以实现原来释放内存的作用，又不会使程序崩溃</li></ul><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code class="language-cpp"><span class="line"><span class="token keyword">constexpr</span> </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,190)]))}const b=t(u,[["render",h]]),m=JSON.parse('{"path":"/guide/knowledge/Qt.html","title":"Qt","lang":"zh-CN","frontmatter":{},"git":{},"filePathRelative":"guide/knowledge/Qt.md"}');export{b as comp,m as data};
