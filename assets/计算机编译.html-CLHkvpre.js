import{_ as e,c as l,d as n,o as s}from"./app-O9I-yMSb.js";const a={};function i(d,t){return s(),l("div",null,t[0]||(t[0]=[n(`<h1 id="计算机编译" tabindex="-1"><a class="header-anchor" href="#计算机编译"><span>计算机编译</span></a></h1><h2 id="_1-编译运行" tabindex="-1"><a class="header-anchor" href="#_1-编译运行"><span>1. 编译运行</span></a></h2><h3 id="_1-1-编译器" tabindex="-1"><a class="header-anchor" href="#_1-1-编译器"><span>1.1 编译器</span></a></h3><ul><li>例如：gcc/g++/cl.exe/MinGW/MSVC</li><li>编译器的核心功能是将 C++ 源代码（.cpp）编译为机器能识别的二进制指令（.o/.obj），再通过链接器生成可执行文件（.exe 等）。下面列出来的不仅仅是编译器，已经丰富为编译套件（包含编译，链接等）。</li></ul><h5 id="_1-1-1-gcc-g" tabindex="-1"><a class="header-anchor" href="#_1-1-1-gcc-g"><span>1.1.1 gcc/g++</span></a></h5><ul><li><strong>全称</strong>：GNU Compiler Collection（GNU 编译器套件，更是一个工具链集合）。</li><li><strong>工具链组成</strong>：</li></ul><table><thead><tr><th>工具</th><th>作用</th></tr></thead><tbody><tr><td><strong>gcc/g++</strong></td><td>C/C++ 编译器，负责将源代码编译为目标文件（.o）。</td></tr><tr><td><strong>ld</strong></td><td>链接器，将多个目标文件链接为可执行文件（.elf）或共享库（.so）。</td></tr><tr><td><strong>ar</strong></td><td>创建静态库（.a），如 <code>ar rcs libexample.a file1.o file2.o</code>。</td></tr><tr><td><strong>as</strong></td><td>汇编器，将汇编代码转换为机器码。</td></tr><tr><td><strong>make</strong></td><td>构建工具，解析 Makefile 并执行编译命令（通常预装在 Linux 中）。</td></tr><tr><td><strong>GDB</strong></td><td>调试器，用于调试程序（如断点、单步执行等）。</td></tr><tr><td><strong>binutils</strong></td><td>辅助工具集（如<code>objdump</code>反汇编、<code>nm</code>查看符号表）。</td></tr></tbody></table><ul><li><strong>作用</strong>： <ul><li><code>gcc</code> 主要编译 C 语言代码；</li><li><code>g++</code> 是 gcc 的 C++ 前端，专门编译 C++ 代码（支持 C++ 标准、STL 等）。</li></ul></li><li><strong>特点</strong>： <ul><li>跨平台（Linux、macOS、Windows 均可安装）；</li><li>开源免费，支持几乎所有 C++ 标准（C++98 到 C++23）；</li><li>是 Linux 系统默认的 C++ 编译器（比如 Ubuntu、CentOS 自带）。</li></ul></li></ul><h5 id="_1-1-2-mingw" tabindex="-1"><a class="header-anchor" href="#_1-1-2-mingw"><span>1.1.2 MinGW</span></a></h5><ul><li><p><strong>全称</strong>：Minimalist GNU for Windows（Windows 上的精简 GNU 工具集）。</p></li><li><p><strong>作用</strong>：是 gcc/g++ 在 Windows 平台的移植版本，让 Windows 系统能使用 gcc/g++ 编译代码。</p></li><li><p><strong>特点</strong>：</p><ul><li>编译出的程序不需要依赖微软的运行时库（如 MSVC 的<code>msvcr120.dll</code>），可独立运行；</li><li>轻量、开源，适合 Windows 平台下的跨平台开发（和 Linux 的 gcc 行为更一致）。</li></ul></li><li><p><strong>Windows 上的 GNU 工具链移植</strong>：将 Linux 下的 GCC、GDB 等工具移植到 Windows，让 Windows 开发者能使用类 Unix 环境开发。</p></li><li><p><strong>跨平台一致性</strong>：编译行为与 Linux/macOS 的 GCC 高度一致，适合需要跨平台的项目（如同时支持 Windows 和 Linux 的 Qt 应用）。</p></li><li><p><strong>工具链组成</strong>：MinGW 工具链包含以下核心组件：</p></li></ul><table><thead><tr><th>工具</th><th>作用</th></tr></thead><tbody><tr><td><strong>gcc/g++</strong></td><td>C/C++ 编译器，负责将源代码编译为目标文件（.o）。</td></tr><tr><td><strong>ld</strong></td><td>链接器，将多个目标文件链接为可执行文件（.exe）或库文件（.dll/.a）。</td></tr><tr><td><strong>make/mingw32-make</strong></td><td>构建工具，解析 Makefile 并执行编译命令。</td></tr><tr><td><strong>GDB</strong></td><td>调试器，用于调试程序（如断点、单步执行等）。</td></tr><tr><td><strong>binutils</strong></td><td>辅助工具集（如<code>ar</code>打包静态库、<code>objdump</code>反汇编）。</td></tr></tbody></table><ul><li><strong>优缺点</strong>：</li></ul><table><thead><tr><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>无需安装 Visual Studio，轻量简洁</td><td>对 Windows 特定 API（如 COM、UWP）支持有限</td></tr><tr><td>编译的程序不依赖微软运行时库</td><td>调试工具（如 GDB）不如 Visual Studio 强大</td></tr><tr><td>与 Linux/macOS 的 GCC 兼容性好</td><td>对最新 C++ 标准（如 C++20/23）支持略滞后</td></tr></tbody></table><ul><li><p><strong>适用场景</strong>：</p><ul><li><strong>跨平台开发</strong>：项目需要同时在 Windows 和 Linux 上运行，且希望使用同一套工具链。</li><li><strong>轻量化需求</strong>：不需要复杂的 Windows 特性（如 UWP、DirectX），追求简单独立的程序。</li><li><strong>教育 / 学习</strong>：适合新手入门，避免 Visual Studio 的复杂安装和配置。</li></ul></li></ul><h4 id="_1-1-3-msvc" tabindex="-1"><a class="header-anchor" href="#_1-1-3-msvc"><span>1.1.3 MSVC</span></a></h4><ul><li><p><strong>全称</strong>：Microsoft Visual C++（微软的 C++ 编译器）。</p></li><li><p><strong>作用</strong>：随 Visual Studio（微软的 IDE）提供，是 Windows 平台的 “原生” 编译套件，工具链中负责编译的是cl.exe。</p></li><li><p><strong>特点</strong>：</p><ul><li>仅支持 Windows 平台；</li><li>对 Windows 系统 API 和微软生态（如.NET、DirectX）支持更好；</li><li>编译速度快，调试工具（如 VS 的调试器）更强大，但闭源且仅绑定 Visual Studio。</li></ul></li><li><p><strong>Windows 原生 C++ 工具链</strong>：微软为 Windows 平台开发的官方工具链，深度集成 Windows 系统 API 和特性。</p></li><li><p><strong>Visual Studio 生态</strong>：与 Visual Studio IDE 紧密结合，提供强大的调试、代码分析等功能。</p></li><li><p><strong>工具链组成</strong>：MSVC 工具链是 Visual Studio 的一部分，包含：</p></li></ul><table><thead><tr><th>工具</th><th>作用</th></tr></thead><tbody><tr><td><strong>cl.exe</strong></td><td>C/C++ 编译器（CL = Compiler），替代 GCC 的<code>g++</code>。</td></tr><tr><td><strong>link.exe</strong></td><td>链接器，替代 GCC 的<code>ld</code>。</td></tr><tr><td><strong>nmake</strong></td><td>构建工具，类似 GNU 的<code>make</code>，但语法略有不同。</td></tr><tr><td><strong>Visual Studio 调试器</strong></td><td>图形化调试工具，支持断点、内存分析、性能分析等高级功能。</td></tr><tr><td><strong>MSBuild</strong></td><td>微软的项目构建系统，替代传统的 Makefile，支持<code>.vcxproj</code>格式。</td></tr><tr><td><strong>Windows SDK</strong></td><td>包含 Windows API 头文件和库文件（如 Win32 API、COM、DirectX）。</td></tr></tbody></table><ul><li><strong>优缺点</strong>：</li></ul><table><thead><tr><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>对 Windows 系统 API（如 UWP、DirectX）支持完美</td><td>必须安装 Visual Studio（占用空间大，安装复杂）</td></tr><tr><td>调试工具（如 VS 调试器）功能强大</td><td>编译的程序依赖微软运行时库（如<code>msvcr120.dll</code>）</td></tr><tr><td>对最新 C++ 标准支持更及时</td><td>不支持跨平台（只能编译 Windows 程序）</td></tr></tbody></table><ul><li><p><strong>适用场景</strong>：</p></li><li><p><strong>Windows 原生应用</strong>：开发依赖 Windows 特定功能的程序（如 UWP 应用、DirectX 游戏）。</p></li><li><p><strong>企业级开发</strong>：团队使用 Visual Studio 协作，需要强大的调试和代码分析工具。</p></li><li><p><strong>高性能需求</strong>：MSVC 对 Windows 系统调用的优化更好，适合性能敏感的程序（如游戏、数据库）。</p></li></ul><table><thead><tr><th><strong>维度</strong></th><th><strong>MinGW</strong></th><th><strong>MSVC</strong></th></tr></thead><tbody><tr><td><strong>依赖库</strong></td><td>不依赖微软运行时库，程序可独立运行</td><td>依赖微软运行时库（需随程序分发）</td></tr><tr><td><strong>调试体验</strong></td><td>依赖 GDB，功能较基础</td><td>Visual Studio 调试器功能强大</td></tr><tr><td><strong>C++ 标准支持</strong></td><td>略滞后于 MSVC（如对 C++20 的 concept 支持稍慢）</td><td>对最新标准支持更及时</td></tr><tr><td><strong>Windows API 支持</strong></td><td>有限（仅支持部分 Win32 API）</td><td>完整支持所有 Windows 特性（包括 UWP、COM）</td></tr><tr><td><strong>跨平台兼容性</strong></td><td>与 Linux/macOS 的 GCC 兼容</td><td>仅支持 Windows 平台</td></tr><tr><td><strong>安装复杂度</strong></td><td>轻量（单独安装包，通常 &lt; 1GB）</td><td>重量级（需安装 Visual Studio，通常 &gt; 5GB）</td></tr></tbody></table><h3 id="_1-2-编译器选项" tabindex="-1"><a class="header-anchor" href="#_1-2-编译器选项"><span>1.2 编译器选项</span></a></h3><ul><li><strong>Windows 系统</strong>： <ul><li>选项通常有 “MinGW 11.2.0”“MSVC 2019”“MSVC 2022” 等。</li><li>MinGW：适合新手，无需额外安装 Visual Studio，编译的程序可独立运行；</li><li>MSVC：需要先安装对应版本的 Visual Studio（如选 MSVC 2022，需先装 VS2022），适合习惯用 VS 调试的用户。</li></ul></li><li><strong>Linux 系统</strong>： <ul><li>通常是 “GCC 11”“GCC 12” 等（即 g++），直接选系统默认的 gcc 版本即可。</li></ul></li><li><strong>macOS 系统</strong>： <ul><li>通常是 “Clang 14”（苹果基于 LLVM 的编译器，类似 gcc，macOS 默认）。</li></ul></li></ul><h3 id="_1-3-构建工具" tabindex="-1"><a class="header-anchor" href="#_1-3-构建工具"><span>1.3 构建工具</span></a></h3><ul><li>例如：make/MSBuild/QMake/Ninja</li><li>负责自动化编译流程</li><li>写代码时，手动输入<code>g++ main.cpp -o app</code>编译单个文件很简单，但大型项目（如 Qt 程序）有上百个源文件，需要<strong>自动化编译</strong>（按依赖顺序编译、链接），这就是构建工具的作用。</li></ul><h4 id="_1-3-1-make" tabindex="-1"><a class="header-anchor" href="#_1-3-1-make"><span>1.3.1 make</span></a></h4><ul><li><strong>作用</strong>：根据<code>Makefile</code>（定义编译规则的文本文件）自动执行编译命令（如<code>gcc -c file.cpp</code>），解决多文件依赖问题。</li><li><strong>特点</strong>： <ul><li>历史悠久，是 Unix/Linux 下的标准构建工具；</li><li>但<code>Makefile</code>需要手动编写，且语法复杂，跨平台兼容性差（Windows 上需要额外安装 MinGW 或 Cygwin 才能用）。</li></ul></li></ul><h4 id="_1-3-2-msbuild" tabindex="-1"><a class="header-anchor" href="#_1-3-2-msbuild"><span>1.3.2 MSBuild</span></a></h4><ul><li>MSBuild 是<strong>Windows 平台的原生构建系统</strong><ul><li><strong>定位</strong><ul><li>解析 Visual Studio 项目文件（<code>.vcxproj</code>、<code>.csproj</code>等），并执行编译、链接等操作；</li><li>与 Visual Studio IDE 深度集成，但也可独立通过命令行使用；</li><li>是微软技术栈（如.NET、C++/CLI、UWP）的官方构建工具。</li></ul></li></ul></li><li><strong>工作流程</strong>： <ul><li>解析<code>.vcxproj</code>中的规则；</li><li>调用 MSVC 编译器（<code>cl.exe</code>）编译源码；</li><li>调用链接器（<code>link.exe</code>）生成可执行文件或库。</li></ul></li></ul><h4 id="_1-3-3-ninja" tabindex="-1"><a class="header-anchor" href="#_1-3-3-ninja"><span>1.3.3 Ninja</span></a></h4><ul><li><strong>定位</strong>：轻量级、高性能的构建工具，通常与 CMake 配合使用。</li><li><strong>工作流程</strong>： <ol><li>用 CMake 生成 Ninja 构建文件（而非 Makefile）：<code>cmake -G &quot;Ninja&quot;</code>；</li><li>执行<code>ninja</code>编译项目。</li></ol></li><li><strong>优点</strong>： <ul><li>编译速度比<code>make</code>快（并行构建优化更好）；</li><li>适合大型项目（如 Qt 自身源码编译）。</li></ul></li></ul><h3 id="_1-4-cmake" tabindex="-1"><a class="header-anchor" href="#_1-4-cmake"><span>1.4 CMake</span></a></h3><h4 id="_1-4-1-构建工具的局限性" tabindex="-1"><a class="header-anchor" href="#_1-4-1-构建工具的局限性"><span>1.4.1 构建工具的局限性</span></a></h4><ul><li>MinGW 中的<code>mingw32-make</code>、MSVC 中的<code>MSBuild</code>属于 <strong>“底层构建工具”</strong>，它们的工作是解析特定格式的构建文件 （如 Makefile、.vcxproj），并按规则执行编译、链接命令。但它们有明显短板：</li></ul><ol><li><p><strong>平台 / 工具链绑定</strong></p><ul><li><code>make</code>/<code>mingw32-make</code>依赖<strong>Makefile</strong>（语法复杂，且 Windows/Linux 下的写法有差异）；</li><li><code>nmake</code>/<code>MSBuild</code>依赖<strong>Visual Studio 的项目文件</strong>（.vcxproj，仅支持 MSVC 工具链，无法在 Linux 上用）。 若项目需要同时支持 MinGW、MSVC、Linux 的 GCC、macOS 的 Clang，你需要为每个工具链写一套独立的构建文件（如 Makefile、.vcxproj、Xcode 项目），维护成本极高。</li></ul></li><li><p><strong>复杂项目管理困难</strong></p><ul><li>对于多文件、多模块、多依赖库（如链接 Qt 库、第三方库）的项目，手动编写 Makefile 或.vcxproj 容易出错（比如路径配置、依赖顺序、条件编译逻辑）；</li><li>大型项目（如 Qt 本身、OpenCV）的构建规则复杂，手动维护几乎不可能。</li></ul></li></ol><h4 id="_1-4-2-cmake-的核心作用" tabindex="-1"><a class="header-anchor" href="#_1-4-2-cmake-的核心作用"><span>1.4.2 CMake 的核心作用</span></a></h4><blockquote><p>[!NOTE] 统一生成跨平台构建文件</p></blockquote><ul><li>CMake 不直接编译代码，而是<strong>根据一份统一的配置文件（CMakeLists.txt），自动生成对应工具链所需的构建文件</strong>（如 Makefile、.vcxproj、Xcode 项目）。简单说： <ul><li>只需要写一份<code>CMakeLists.txt</code>，声明 “源代码在哪、依赖哪些库、编译选项是什么”；</li><li>CMake 会根据你当前的工具链（如 MinGW/MSVC/GCC/Clang）和平台（Windows/Linux/macOS），自动生成该工具链能识别的构建文件（比如给 MinGW 生成 Makefile，给 MSVC 生成.vcxproj，给 Linux 生成 GCC 的 Makefile）。</li></ul></li><li><strong>作用</strong>：<strong>跨平台的构建系统生成器</strong>（比 make，MSBuild 更高层）。</li><li><strong>工作流程</strong>： <ol><li>开发者编写<code>CMakeLists.txt</code>（简单的跨平台配置文件），定义项目结构、编译选项等；</li><li>CMake 根据<code>CMakeLists.txt</code>，自动生成对应平台的构建文件（比如 Linux 的<code>Makefile</code>、Windows 的 Visual Studio 项目文件、macOS 的 Xcode 项目）；</li><li>再通过对应平台的构建工具（make、VS、Xcode）执行编译。</li></ol></li><li><strong>特点</strong>： 解决了 make 的跨平台痛点，是目前大型 C++ 项目的主流构建工具</li><li>MinGW 和 MSVC 包含的构建工具（如<code>make</code>/<code>mingw32-make</code>、<code>nmake</code>/<code>MSBuild</code>）是<strong>直接执行编译流程的工具</strong>，而 CMake 是 <strong>“生成构建工具所需文件的工具”</strong>（元构建系统，Meta-build System）。两者的定位完全不同，CMake 的核心价值是解决跨平台、跨工具链的构建兼容性问题 ，尤其在复杂项目中不可替代。</li></ul><table><thead><tr><th>场景</th><th>直接用构建工具（make/MSBuild）</th><th>用 CMake</th></tr></thead><tbody><tr><td>跨平台支持</td><td>需要手动写多套构建文件（维护成本极高）</td><td>一份 CMakeLists.txt 适配所有平台</td></tr><tr><td>多工具链切换（MinGW→MSVC）</td><td>需重新编写构建文件</td><td>只需重新生成一次构建文件（一键切换）</td></tr><tr><td>复杂项目（多依赖 / 多模块）</td><td>手动维护容易出错，依赖关系混乱</td><td>自动处理依赖、路径、编译选项，结构清晰</td></tr><tr><td>团队协作</td><td>不同成员可能用不同工具链，构建规则不统一</td><td>统一配置文件，避免 “在我这能编，在你那报错”</td></tr></tbody></table><h4 id="_1-4-3-cmake-与构建工具的关系" tabindex="-1"><a class="header-anchor" href="#_1-4-3-cmake-与构建工具的关系"><span>1.4.3 CMake 与构建工具的关系</span></a></h4><ul><li>构建工具（<code>make</code>/<code>MSBuild</code>等）是 <strong>“工人”</strong>，负责按图纸（Makefile/.vcxproj）施工（编译代码）；</li><li>CMake 是 <strong>“图纸设计师”</strong>，根据你的需求（CMakeLists.txt），为不同 “工人”（工具链）绘制对应的 “施工图纸”（构建文件）。</li></ul><h4 id="_1-4-4-cmake优势" tabindex="-1"><a class="header-anchor" href="#_1-4-4-cmake优势"><span>1.4.4 CMake优势</span></a></h4><p>如果项目需要同时支持Windows（MinGW/MSVC）、Linux（GCC）、macOS（Clang），直接用<code>make</code>或<code>MSBuild</code>几乎无法实现：</p><ul><li>不同平台的库路径（如 Qt 库在 Windows 是<code>C:\\Qt\\...</code>，在 Linux 是<code>/usr/lib/qt5/...</code>）、编译选项（如 Windows 需要<code>-DWIN32</code>，Linux 需要<code>-DLINUX</code>）、链接方式（如 Windows 的<code>.dll</code>和 Linux 的<code>.so</code>）差异极大；</li><li>用 CMake 的话，只需在<code>CMakeLists.txt</code>中通过<code>find_package(Qt5 COMPONENTS Core Widgets)</code>声明依赖，CMake 会自动适配不同平台的 Qt 库路径和编译规则，无需手动修改。</li></ul><p>即使只在 Windows 开发，若需要在<strong>MinGW 和 MSVC 之间切换</strong>（比如测试不同工具链的兼容性），CMake 能避免重复劳动：</p><ul><li>无需为 MinGW 写一套 Makefile，再为 MSVC 写一套.vcxproj；</li><li>只需运行<code>cmake -G &quot;MinGW Makefiles&quot;</code>生成 MinGW 的构建文件，或<code>cmake -G &quot;Visual Studio 17 2022&quot;</code>生成 MSVC 的.vcxproj，同一份<code>CMakeLists.txt</code>通用。</li></ul><h2 id="_2-gcc" tabindex="-1"><a class="header-anchor" href="#_2-gcc"><span>2. GCC</span></a></h2><p>GCC 编译器通常以 Linux 命令的形式在终端（Shell）中使用。</p><p>如果需要其他特定的GCC组件，例如C++编译器（g++）或Fortran编译器（gfortran），需要额外再安装。</p><p>指令格式：gcc [options] [filenames]</p><table><thead><tr><th style="text-align:left;">选项</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">-c</td><td style="text-align:left;">只编译源代码，生成目标文件（xx.o）而不进行链接</td></tr><tr><td style="text-align:left;">-E</td><td style="text-align:left;">只进行预处理，生成预处理后的源代码文件</td></tr><tr><td style="text-align:left;">-O</td><td style="text-align:left;">优化生成的代码，可以使用-O1、-O2或-O3进行不同级别的优化(是大写字母O)</td></tr><tr><td style="text-align:left;">-g</td><td style="text-align:left;">生成调试信息，以便进行源代码级调试</td></tr><tr><td style="text-align:left;">-Wall</td><td style="text-align:left;">显示编译时的警告信息</td></tr><tr><td style="text-align:left;">-std</td><td style="text-align:left;">指定所使用的C语言标准，如-std=c11</td></tr><tr><td style="text-align:left;">-I</td><td style="text-align:left;">指定包含头文件的目录</td></tr><tr><td style="text-align:left;">-L</td><td style="text-align:left;">指定链接库文件的目录</td></tr><tr><td style="text-align:left;">-l</td><td style="text-align:left;">链接指定的库文件</td></tr></tbody></table><h2 id="_3-gdb" tabindex="-1"><a class="header-anchor" href="#_3-gdb"><span>3. GDB</span></a></h2><ul><li>要想使用gdb，需要在编译时开启调试功能</li></ul><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code class="language-cpp"><span class="line">gcc：在编译时添加 <span class="token operator">-</span>g 选项生成调试信息</span>
<span class="line">gcc <span class="token operator">-</span>g <span class="token operator">-</span>o program program<span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token operator">-</span>g：生成调试符号，便于 GDB 进行源代码级调试。<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">Makefile：大项目时添加</span>
<span class="line">CC <span class="token operator">=</span> gcc</span>
<span class="line">CFLAGS <span class="token operator">=</span> <span class="token operator">-</span>Wall <span class="token operator">-</span>g</span>
<span class="line"></span>
<span class="line">CMakeLists<span class="token punctuation">.</span>txt：构建工具</span>
<span class="line">对于C<span class="token operator">++</span><span class="token operator">:</span></span>
<span class="line">在CMakeLists<span class="token punctuation">.</span>txt文件中添加如下语句：</span>
<span class="line"><span class="token function">SET</span><span class="token punctuation">(</span>CMAKE_BUILD_TYPE <span class="token string">&quot;Debug&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">SET</span><span class="token punctuation">(</span>CMAKE_CXX_FLAGS_DEBUG <span class="token string">&quot;$ENV{CXXFLAGS} -O0 -Wall -g2 -ggdb&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">SET</span><span class="token punctuation">(</span>CMAKE_CXX_FLAGS_RELEASE <span class="token string">&quot;$ENV{CXXFLAGS} -O3 -Wall&quot;</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">对于C<span class="token operator">:</span></span>
<span class="line">在CMakeLists<span class="token punctuation">.</span>txt文件中添加如下语句：</span>
<span class="line"><span class="token function">SET</span><span class="token punctuation">(</span>CMAKE_BUILD_TYPE <span class="token string">&quot;Debug&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">SET</span><span class="token punctuation">(</span>CMAKE_C_FLAGS_DEBUG <span class="token string">&quot;$ENV{CFLAGS} -O0 -Wall -g -ggdb&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">SET</span><span class="token punctuation">(</span>CMAKE_C_FLAGS_RELEASE <span class="token string">&quot;$ENV{CFLAGS} -O3 -Wall&quot;</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>gdb指令</li></ul><table><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">说明</th><th style="text-align:left;">指令</th></tr></thead><tbody><tr><td style="text-align:left;">安装</td><td style="text-align:left;">查看是否安装了gdb</td><td style="text-align:left;">rpm -qa|grep gdb</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">查看安装版本</td><td style="text-align:left;">gdb -v</td></tr><tr><td style="text-align:left;">启动</td><td style="text-align:left;">启动gdb</td><td style="text-align:left;">gdb program</td></tr><tr><td style="text-align:left;">退出</td><td style="text-align:left;">退出gdb</td><td style="text-align:left;">quit；q</td></tr><tr><td style="text-align:left;">显示当前文件源码</td><td style="text-align:left;">显示第linenum行的上下文内容</td><td style="text-align:left;">list linenum</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">显示函数名为function的函数的源程序</td><td style="text-align:left;">list function</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">显示当前行后面的源程序</td><td style="text-align:left;">list</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">显示当前文件开始处的源程序</td><td style="text-align:left;">list -</td></tr><tr><td style="text-align:left;">显示其他文件源码</td><td style="text-align:left;">显示file文件下第linenum行</td><td style="text-align:left;">list file:linenum</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">显示file文件的函数名为function的函数的源程序</td><td style="text-align:left;">list file:function</td></tr><tr><td style="text-align:left;">显示源码设置</td><td style="text-align:left;">设置一次显示源代码的函数（一般打印当前行的上5行和下5行，默认是10行）</td><td style="text-align:left;">set listsize count</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">查看当前listsize的设置</td><td style="text-align:left;">show listsize</td></tr><tr><td style="text-align:left;">断点</td><td style="text-align:left;">设置断点</td><td style="text-align:left;">break；b</td></tr><tr><td style="text-align:left;">当前文件打断点</td><td style="text-align:left;">在第10行设置断点</td><td style="text-align:left;">b 10</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">在func函数入口处设置断点</td><td style="text-align:left;">b func</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">设置临时断点（temporary breakpoint），即断点只会在首次触发后被自动删除</td><td style="text-align:left;">tbreak &lt;location&gt;；例如b xxx.c:n if intValue ==5表示 如果intValue的值等于5，在xxx.c文件第n行中设置断点</td></tr><tr><td style="text-align:left;">其他文件打断点</td><td style="text-align:left;">在源文件为filename的linenum行设置断点</td><td style="text-align:left;">b filename:linenum</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">在源文件filename的function函数的入口处设置断点</td><td style="text-align:left;">b filename:function</td></tr><tr><td style="text-align:left;">断点查询</td><td style="text-align:left;">查询所有断点</td><td style="text-align:left;">info b；info break； i b</td></tr><tr><td style="text-align:left;">删除断点</td><td style="text-align:left;">删除所有的断点</td><td style="text-align:left;">delete</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">删除断点为num的断点</td><td style="text-align:left;">delete num</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">删除不连续的断点 num1 num3</td><td style="text-align:left;">delete num1 num3</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">删除连续的断点，删除 n-m的断点</td><td style="text-align:left;">delete n-m</td></tr><tr><td style="text-align:left;">禁用断点</td><td style="text-align:left;">指定断点无效,不会删除断点</td><td style="text-align:left;">disable[range…]；dis [range…]</td></tr><tr><td style="text-align:left;">启用断点</td><td style="text-align:left;">指定断点有效，对应解开disable设置的无效断点</td><td style="text-align:left;">enable[range…]；ena[range…]</td></tr><tr><td style="text-align:left;">运行控制</td><td style="text-align:left;">执行代码</td><td style="text-align:left;">run；r</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">退出进入的函数，执行到当前函数返回为止</td><td style="text-align:left;">finish；fin</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">循环体内运行程序，直到退出循环体</td><td style="text-align:left;">untile；u</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">继续运行程序，如果有断点，则调到下一个断点处</td><td style="text-align:left;">continue；c</td></tr><tr><td style="text-align:left;">单步调试</td><td style="text-align:left;">函数调用当做一条简单语句执行</td><td style="text-align:left;">next；n</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">函数调用进入被调用函数体内</td><td style="text-align:left;">step；s</td></tr><tr><td style="text-align:left;">查看运行时变量的值</td><td style="text-align:left;">打印var的值</td><td style="text-align:left;">print var；p var</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">打印var的地址</td><td style="text-align:left;">print &amp;var；p &amp;var</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">查看var的类型</td><td style="text-align:left;">ptype var</td></tr><tr><td style="text-align:left;">自动显示变量的值，当程序停住时，或在单步追踪时，这些变量会自动显示</td><td style="text-align:left;">设置自动显示</td><td style="text-align:left;">display 变量名</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">查看display设置的自动显示的信息</td><td style="text-align:left;">info display</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">删除自动显示</td><td style="text-align:left;">undisplay num(info display时显示的编号）</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">删除自动显示</td><td style="text-align:left;">delete display num</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">禁用num显示</td><td style="text-align:left;">disable display num</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">启用num显示</td><td style="text-align:left;">enable display num</td></tr><tr><td style="text-align:left;">监视变量</td><td style="text-align:left;">监视变量var的值，当变量的值发生改变时，停止程序的执行</td><td style="text-align:left;">watch var；w var</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">查看watch设置的监视点的信息</td><td style="text-align:left;">info watchpoints</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">禁用num监视</td><td style="text-align:left;">disable num</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">启用num监视</td><td style="text-align:left;">enable num</td></tr><tr><td style="text-align:left;">堆栈跟踪</td><td style="text-align:left;">显示当前函数调用的堆栈跟踪信息</td><td style="text-align:left;">backtrace；bt</td></tr><tr><td style="text-align:left;">查看当前调试状态的信息</td><td style="text-align:left;">查看断点</td><td style="text-align:left;">info break；i b</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">查看display</td><td style="text-align:left;">info display</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">查看watch</td><td style="text-align:left;">info w</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">查看函数的参数列表</td><td style="text-align:left;">info args</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">查看当前函数的局部变量</td><td style="text-align:left;">info locals</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">查看寄存器的值</td><td style="text-align:left;">info registers；i r</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">显示当前线程的列表</td><td style="text-align:left;">info threads</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">显示当前进程接收到的信号</td><td style="text-align:left;">info signals</td></tr></tbody></table><ul><li>在 Linux 操作系统中，当程序执行发生异常崩溃时，系统可以将发生崩溃时的内存数据、调用堆栈情况等信息自动记录下载，并存储到一个文件中，该文件通常称为 core 文件，Linux 系统所具备的这种功能又称为核心转储（core dump）。GDB 对 core 文件的分析和调试提供有非常强大的功能支持，也可以通过 GDB 调试产生的 core 文件来快速解决问题。</li></ul><ol start="3"><li>查看是否开启 core dump 这一功能 ：ulimit -a</li><li>core file size（core 文件大小）对应的值为 0，表示当前系统未开启 core dump 功能</li><li>开启 core dump：ulimit -c unlimited （unlimited 表示不限制 core 文件的大小）</li></ol><h2 id="_4-cmaklists" tabindex="-1"><a class="header-anchor" href="#_4-cmaklists"><span>4. CMakLists</span></a></h2><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code class="language-cpp"><span class="line"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">CMakeList<span class="token punctuation">.</span>txt</span></span></span>
<span class="line"><span class="token function">cmake_minimum_required</span><span class="token punctuation">(</span>VERSION <span class="token number">3.15</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"># 项目信息</span>
<span class="line"><span class="token function">project</span><span class="token punctuation">(</span>MyProject VERSION <span class="token number">1.0</span> LANGUAGES CXX<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"># 设置默认构建类型为 Debug</span>
<span class="line"><span class="token function">set</span><span class="token punctuation">(</span>CMAKE_BUILD_TYPE Debug<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"># 指定 C<span class="token operator">++</span> 标准</span>
<span class="line"><span class="token function">set</span><span class="token punctuation">(</span>CMAKE_CXX_STANDARD <span class="token number">17</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">set</span><span class="token punctuation">(</span>CMAKE_CXX_STANDARD_REQUIRED ON<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"># 针对 Debug 模式的编译选项</span>
<span class="line"><span class="token function">set</span><span class="token punctuation">(</span>CMAKE_CXX_FLAGS_DEBUG <span class="token string">&quot;-g -O0&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">set</span><span class="token punctuation">(</span>CMAKE_C_FLAGS_DEBUG <span class="token string">&quot;-g -O0&quot;</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"># 添加可执行目标</span>
<span class="line"><span class="token function">add_executable</span><span class="token punctuation">(</span>my_executable main<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,60)]))}const r=e(a,[["render",i]]),c=JSON.parse('{"path":"/guide/knowledge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E8%AF%91.html","title":"计算机编译","lang":"zh-CN","frontmatter":{},"git":{},"filePathRelative":"guide/knowledge/计算机编译.md"}');export{r as comp,c as data};
