import{_ as i,c as a,d as s,o as t}from"./app-ZTDKGR0h.js";const e="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-CUb99K28.png",n="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-qu1FrPbX.png",r="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2-B18WNkfv.png",o="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-3-BRs-vAOX.png",p="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-4-FL6I05C8.png",h="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-7-GmljFOUu.png",d="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-5-C-TuK4qJ.png",c="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-6-CTQrkwaE.png",E="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-8-C3FXeuS6.png",T="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-9-GjBbRMH4.png",b="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-10-ChDnnPM6.png",g="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-11-CwEhVQtt.png",B="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-12-C60uQv3z.png",C="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-13-QQ7O3TUQ.png",u="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-14-BDrCOk-G.png",P="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-15-RSjq4utD.png",A="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-16-Dy9NCG69.png",S="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-17-BwNjF69M.png",m="/Yanran_blog/assets/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-18-CXUQGYYi.png",_={};function f(x,l){return t(),a("div",null,l[0]||(l[0]=[s('<h1 id="计算机网络" tabindex="-1"><a class="header-anchor" href="#计算机网络"><span>计算机网络</span></a></h1><h2 id="osi七层模型" tabindex="-1"><a class="header-anchor" href="#osi七层模型"><span>OSI七层模型</span></a></h2><h3 id="模型介绍" tabindex="-1"><a class="header-anchor" href="#模型介绍"><span>模型介绍</span></a></h3><table><thead><tr><th style="text-align:center;">名称</th><th style="text-align:left;">概述</th></tr></thead><tbody><tr><td style="text-align:center;">物理层</td><td style="text-align:left;">底层数据传输，如网线；网卡标准。</td></tr><tr><td style="text-align:center;">数据链路层</td><td style="text-align:left;">定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。</td></tr><tr><td style="text-align:center;">网络层</td><td style="text-align:left;">定义IP编址，定义路由功能；如不同设备的数据转发。</td></tr><tr><td style="text-align:center;">传输层</td><td style="text-align:left;">端到端传输数据的基本功能；如TCP、UDP。</td></tr><tr><td style="text-align:center;">会话层</td><td style="text-align:left;">控制应用程序之间会话能力；如不同软件数据分发给不同软件。</td></tr><tr><td style="text-align:center;">表示层</td><td style="text-align:left;">数据格式标识，基本压缩加密功能。</td></tr><tr><td style="text-align:center;">应用层</td><td style="text-align:left;">各种应用软件；包括Web应用。</td></tr></tbody></table><p><img src="'+e+'" alt="600"></p><h3 id="说明" tabindex="-1"><a class="header-anchor" href="#说明"><span>说明</span></a></h3><ul><li>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</li><li>数据链路层：接收来自物理层的位流形式的数据，并封装成帧，传送到上一层</li><li>网络层：将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。</li><li>传输层：在源端与目的端之间提供可靠的透明数据传输。</li><li>会话层：负责在网络中的两节点之间建立、维持和终止通信。</li><li>表示层：处理用户信息的表示问题，数据的编码，压缩和解压缩，数据的加密和解密。</li><li>应用层：为用户的应用进程提供网络通信服务。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li>传输层数据又被称作<strong>TCP报文段</strong>或<strong>UDP用户数据报（Segments）</strong></li><li>网络层数据被称作<strong>包（Packages）</strong></li><li>数据链路层的数据被称作<strong>帧（Frames）</strong></li><li>物理层的数据被称作<strong>比特流（Bits）</strong></li><li>网络七层模型是一个标准，而非实现</li><li>网络四层模型是一个实现的应用模型</li></ul><h2 id="tcp三次握手" tabindex="-1"><a class="header-anchor" href="#tcp三次握手"><span>TCP三次握手</span></a></h2><p><img src="'+n+'" alt="600"></p><h2 id="完整http请求包括哪些内容" tabindex="-1"><a class="header-anchor" href="#完整http请求包括哪些内容"><span>完整HTTP请求包括哪些内容</span></a></h2><ol><li>客户端域名解析</li><li>TCP的3次握手</li><li>客户端发起HTTP请求</li><li>服务器响应HTTP请求</li><li>客户端浏览器接收得到HTML代码</li><li>浏览器解析HTML代码，并请求HTML代码中的资源（如js、css、图片）</li><li>浏览器对页面进行渲染呈现给用户</li></ol><h2 id="dns是什么" tabindex="-1"><a class="header-anchor" href="#dns是什么"><span>DNS是什么</span></a></h2><h2 id="dns的工作原理" tabindex="-1"><a class="header-anchor" href="#dns的工作原理"><span>DNS的工作原理</span></a></h2><ul><li>DNS将主机名转换为IP地址，属于应用层协议，使用UDP传输。</li><li>当用户输入域名时，浏览器先检查自己的缓存中是否包含这个域名映射的ip地址，1）有解析结束。 2）若没命中，则检查操作系统缓存（如Windows的hosts）中有没有解析过的结果，有解析结束。 3）若无命中，则请求本地域名服务器解析（LDNS）。 4）若LDNS没有命中就直接跳到根域名服务器请求解析。根域名服务器返回给LDNS一个 主域名服务器地址。 5）此时LDNS再发送请求给上一步返回的gTLD（ 通用顶级域）， 接受请求的gTLD查找并返回这个域名对应的Name Server的地址 。6）Name Server根据映射关系表找到目标ip，返回给LDNS。</li></ul><h2 id="rpc" tabindex="-1"><a class="header-anchor" href="#rpc"><span>RPC</span></a></h2><h3 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1"><span>总结</span></a></h3><ul><li>用于实现不同服务间的远程调用，如gRPC、Thrift和Dubbo。它涉及服务寻址、序列化和网络传输，简化了跨平台调用。RPC常用于大型网站的微服务架构，通过注册中心进行服务发现，并提供安全性和服务治理。</li></ul><p><img src="'+r+'" alt="800"></p><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h3><ol><li>RPC（Remote Procedure Call Protocol） 远程过程调用协议。</li><li>RPC是一种通过网络从远程计算机程序上请求服务，不需要了解底层网络技术的协议。</li><li>RPC主要作用就是不同的服务间方法调用就像本地调用一样便捷。</li></ol><h3 id="常用rpc技术或框架" tabindex="-1"><a class="header-anchor" href="#常用rpc技术或框架"><span>常用RPC技术或框架</span></a></h3><ol start="4"><li>应用级的服务框架：阿里的 Dubbo/Dubbox、Google gRPC、Spring Boot/Spring Cloud。</li><li>远程通信协议：RMI、Socket、SOAP(HTTP XML)、REST(HTTP JSON)。</li><li>通信框架：MINA 和 Netty</li></ol><h3 id="主流的grpc、thrift、dubbo" tabindex="-1"><a class="header-anchor" href="#主流的grpc、thrift、dubbo"><span>主流的gRPC、Thrift、Dubbo</span></a></h3><ol start="7"><li>gRPC：gRPC是Google开源软件，gRPC是基于HTTP2.0协议，而HTTP2.0是基于二进制的HTTP协议升级版本，底层使用Netty框架支持。</li><li>Thrift：Thrift是Facebook开源项目，其是一个跨语言的服务开发框架。用户只需在进行二开即可，对底层的RPC通讯透明。</li><li>Dubbo：Dubbo是阿里开源组件协议和序列化框架都可以插拔，依托Spring框架开发，远程接口是基于Java接口，适用于微服务架构。</li></ol><h3 id="rpc作用" tabindex="-1"><a class="header-anchor" href="#rpc作用"><span>RPC作用</span></a></h3><ol start="10"><li>服务化：微服务化，跨平台的服务之间远程调用；</li><li>分布式系统架构：分布式服务跨机器进行远程调用；</li><li>服务可重用：开发一个公共能力服务，供多个服务远程调用。</li><li>系统间交互调用：两台服务器A、B，服务器A上的应用a需要调用服务器B上的应用b提供的方法，而应用a和应用b不在一个内存空间，不能直接调用，此时，需要通过网络传输来表达需要调用的语义及传输调用的数据。</li></ol><h3 id="架构" tabindex="-1"><a class="header-anchor" href="#架构"><span>架构</span></a></h3><p><img src="'+o+'" alt=""></p><h3 id="调用过程" tabindex="-1"><a class="header-anchor" href="#调用过程"><span>调用过程</span></a></h3><p><img src="'+p+'" alt=""></p><ol><li>客户端（Client）通过本地调用的方式调用服务（以接口方式调用）；</li><li>客户端存根（Client Stub）接收到调用请求后负责将方法、入参等信息进行组装序列化成能够进行网络传输的消息体（将消息体对象序列化为二进制流）；</li><li>客户端存根（Client Stub）找到远程的服务地址，并且将消息通过网络发送给服务端（通过sockets发送消息）；</li><li>服务端存根（Server Stub）收到消息后进行反序列化操作，即解码（将二进制流反序列化为消息对象）；</li><li>服务端存根（Server Stub）通过解码结果调用本地的服务进行相关处理；</li><li>服务端（Server）本地服务业务处理；</li><li>服务端（Server）将处理结果返回给服务端存根；</li><li>服务端存根（Server Stub）序列化处理结果（将结果消息对象序列化为二进制流）；</li><li>服务端存根（Server Stub）将序列化结果通过网络发送至客户端（通过sockets发送消息）；</li><li>客户端存根（Server Stub）接收到消息，进行反序列化解码（将结果二进制流反序列化为消息对象）；</li><li>客户端得到最终的结果。</li></ol><h3 id="核心功能" tabindex="-1"><a class="header-anchor" href="#核心功能"><span>核心功能</span></a></h3><ol><li>客户端：Client，服务调用方。</li><li>客户端存根：Client Stub，存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端。</li><li>服务端存根：Server Stub，接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。</li><li>服务端：Server，服务的真正提供者。</li><li>newtwork service：底层传输，tcp或http</li></ol><h3 id="功能实现" tabindex="-1"><a class="header-anchor" href="#功能实现"><span>功能实现</span></a></h3><p>功能实现主要分为服务寻址、序列化和反序列化、网络传输功能。</p><h4 id="服务寻址功能" tabindex="-1"><a class="header-anchor" href="#服务寻址功能"><span>服务寻址功能</span></a></h4><ol><li>本地：在本地方法调用中，函数体是直接通过函数指针来指定的，但是在远程调用中，由于两个进程的地址空间完全不一样，函数指针不起作用。</li><li>远程：RPC中所有函数或方法都有自己的一个ID，在所有进程中都唯一。客户端在做远程过程调用时，必须附上这个ID，即客户端会查一下表，找出相应的Call ID，然后传给服务端，服务端也会查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</li><li>Call ID映射表一般是一个哈希表。</li><li>需要通过服务注册中心去查询对方服务有哪些实例。</li></ol><h4 id="序列化和反序列化功能" tabindex="-1"><a class="header-anchor" href="#序列化和反序列化功能"><span>序列化和反序列化功能</span></a></h4><ol><li>序列化：将消息对象转换为二进制流。</li><li>反序列化：将二进制流转换为消息对象。</li><li>远程调用涉及到数据的传输，在本地调用中，只需要将数据压入栈中，然后让函数去栈中读取即可。</li><li>但远程的数据传输，由于客户端和服务端不在同一个服务器上，涉及不同的进程，不能通过内存传递参数，此时就需要将客户端先将请求参数转成字节流（编码），传递给服务端，服务端再将字节流转为自己可读取格式（解码），这就是序列化和反序列化的过程。反之，服务端返回值也逆向经历序列化和反序列化到客户端。</li><li>序列化的优势：将消息对象转为二进制字节流，便于网络传输。可跨平台、跨语言。如Python编写的客户端请求序列化参数传输到Java编写的服务端进行反序列化。</li></ol><h4 id="网络传输功能" tabindex="-1"><a class="header-anchor" href="#网络传输功能"><span>网络传输功能</span></a></h4><ol><li>客户端将Call ID和序列化后的参数字节流传输给服务端。</li><li>服务端将序列化后的调用结果回传给客户端。</li><li>协议：主要有TCP、UDP、HTTP协议。</li><li>基于TCP协议 <ul><li>客户端和服务端建立Socket连接。</li><li>客户端通过Socket将需要调用的接口名称、方法名称及参数序列化后传递给服务端。</li><li>服务端反序列化后再利用反射调用对应的方法，将结果返回给客户端。</li></ul></li><li>基于HTTP协议 <ul><li>客户端向服务端发送请求，如GET、POST、PUT、DELETE等请求。</li><li>服务端根据不同的请求参数和请求URL进行方法调用，返回JSON或者XML数据结果。</li></ul></li><li>TCP和HTTP对比</li></ol><ul><li>基于TCP协议实现的RPC调用，由于是底层协议栈，更佳灵活的对协议字段进行定制，可减少网络开销，提高性能，实现更大的吞吐量和并发数。但，底层复杂，实现代价高。</li><li>基于HTTP协议实现的RPC调用，已封装实现序列化，但HTTP属于应用层协议，HTTP传输所占用的字节数比TCP更高，传输效率对比TCP较低。</li></ul><h2 id="mqtt" tabindex="-1"><a class="header-anchor" href="#mqtt"><span>mqtt</span></a></h2><h3 id="总结-2" tabindex="-1"><a class="header-anchor" href="#总结-2"><span>总结</span></a></h3><ul><li>MQTT是一种轻量级的物联网通信协议，基于发布/订阅模式，支持QoS级别。它具有精简的协议设计，开放的消息协议，以及广泛应用于物联网、M2M通信、消息推送和智能设备等领域。MQTT协议涉及发布者、订阅者和消息代理（Broker）的角色，以及连接、订阅、发布消息的过程，并包含会话保持和心跳机制，确保消息的可靠传输。</li><li>MQTT(Message Queuing Telemetry Transport, 消息队列遥测传输协议)，是一种基于发布/订阅(publish/subscribe)模式的&quot;轻量级&quot;通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为远程连接设备提供实时可靠的消息服务，作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用</li><li>MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如:机器与机器（M2M）通信和物联网(loT)。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</li></ul><h3 id="mqtt特点" tabindex="-1"><a class="header-anchor" href="#mqtt特点"><span>MQTT特点</span></a></h3><ol start="7"><li>基于Publish/Subscribe(发布/订阅)模式的物联网通信协议</li><li>简单易实现</li><li>支持Qos(服务质量)</li><li>报文精简</li><li>基于TCP/IP</li></ol><h3 id="设计规范" tabindex="-1"><a class="header-anchor" href="#设计规范"><span>设计规范</span></a></h3><ol start="12"><li>精简，不添加可有可无的功能；</li><li>发布/订阅(Pub/Sub)模式，方便消息在传感器之间传递，解耦Client/Server模式，带来的好处在于不必预先知道对方的存在(ip/port), 不必同时运行</li><li>允许用户动态创建主题(不需要预先创建主题)，零运维成本；</li><li>把传输量降到最低以提高传输效率</li><li>把低带宽、高延迟、不稳定的网络等因素考虑在内；</li><li>支持连续的会话保持和控制(心跳协议)</li><li>理解客户端计算能力可能很低</li><li>提供服务质量( quality of service level: QoS)管理:</li><li>不强求传输数据的类型与格式，保持灵活性(指的使应用层业务数据)</li></ol><h3 id="主要特性" tabindex="-1"><a class="header-anchor" href="#主要特性"><span>主要特性</span></a></h3><ol start="21"><li>开放消息协议，简单易实现。</li><li>使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。</li><li>对负载（协议携带的应用数据）内容屏蔽的消息传输。</li><li>基于TCP/IP网络连接,提供有序，无损，双向连接。主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。由于基于不同的连接方式，优缺点自然也就各有不同了。</li><li>消息服务质量(QoS）支持，可靠传输保证;有三种消息发布服务质量: <ul><li>QoS0:“至多一次”，消息发布完全依赖底层TCP/IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。</li><li>QoS1:“至少—次”，确保消息到达，但消息重复可能会发生。</li><li>QoS2:“只有一次”，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。</li></ul></li><li>1字节固定报头，2字节心跳报文，最小化传输开销和协议交换，有效减少网络流量。这就是为什么在介绍里说它非常适合&quot;在物联网领域，传感器与服务器的通信，信息的收集，要知道嵌入式设备的运算能力和带宽都相对薄弱，使用这种协议来传递消息再适合不过了。</li><li>在线状态感知:使用Last Will和Testament特性通知有关各方客户端异常中断的机制。 <ul><li>Last Will:即遗言机制，用于通知同一主题下的其他设备，发送遗言的设备已经断开了连接。</li><li>Testament:遗嘱机制，功能类似于Last Will。</li></ul></li></ol><h3 id="主题订阅" tabindex="-1"><a class="header-anchor" href="#主题订阅"><span>主题订阅</span></a></h3><p><img src="'+h+'" alt=""></p><h4 id="发布订阅模式" tabindex="-1"><a class="header-anchor" href="#发布订阅模式"><span>发布订阅模式</span></a></h4><p><img src="'+d+'" alt=""></p><p>客户端只需要订阅这个主题，当有其他客户端向这个服务端发布消息时，这个客户端就可以收到这个消息</p><h4 id="请求响应模式" tabindex="-1"><a class="header-anchor" href="#请求响应模式"><span>请求响应模式</span></a></h4><p><img src="'+c+'" alt=""></p><p>请求响应模式: 客户端向服务端发送请求，服务端收到请求后，向客户端返回响应</p><h3 id="协议原理" tabindex="-1"><a class="header-anchor" href="#协议原理"><span>协议原理</span></a></h3><h4 id="实现方式" tabindex="-1"><a class="header-anchor" href="#实现方式"><span>实现方式</span></a></h4><p>实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份: 发布者(Publish)、代理(Broker)(服务器)、订阅者(Subscribe)。 其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p><p><img src="'+E+`" alt=""></p><p>MQTT传输的消息分为: 主题(Topic) 和 负载(payload)两部分: 28. Topic: 可以理解为消息的类型，订阅者订阅(Subscribe)后，就会收到该主题的消息内容(payload)<br> 29. payload: 可以理解为消息的内容，是指订阅者具体要使用的内容</p><h4 id="网络传输与应用消息" tabindex="-1"><a class="header-anchor" href="#网络传输与应用消息"><span>网络传输与应用消息</span></a></h4><ul><li>MQTT会构建底层网络传输: 它将建立客户端到服务器的连接，提供两者之间的一个<strong>有序的、无损的、基于字节流的双向传输。</strong></li><li>当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量(QoS)和主题名(Topic)相关联</li></ul><h4 id="mqtt客户端" tabindex="-1"><a class="header-anchor" href="#mqtt客户端"><span>MQTT客户端</span></a></h4><p>一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以</p><ol start="30"><li>发布其他客户端可能会订阅的信息</li><li>订阅其他客户端发布的消息</li><li>退定或删除应用程序的消息</li><li>断开与服务器的连接</li></ol><h4 id="mqtt服务器端" tabindex="-1"><a class="header-anchor" href="#mqtt服务器端"><span>MQTT服务器端</span></a></h4><p>MQTT服务器以称为&quot;消息代理&quot;(Broker), 可以是一个应用程序或一台设备，它是位于消息发布者和订阅者之间，它可以:</p><ol start="34"><li>接受来自客户的网络连接</li><li>接受客户发布的应用信息</li><li>处理来自客户端的订阅和退订请求</li><li>向订阅的客户转发应用程序消息</li></ol><h4 id="发布-订阅、主题、会话" tabindex="-1"><a class="header-anchor" href="#发布-订阅、主题、会话"><span>发布/订阅、主题、会话</span></a></h4><ul><li>MQTT是基于<strong>发布(Publish)</strong>/<strong>订阅(Subscribe)<strong>模式来进行通信及数据交换的，与HTTP的</strong>请求(Request)</strong>/**应答(Response)**的模式有本质的不同</li><li>**订阅者(Subscriber)**会向 <strong>消息服务器(Broker)<strong>订阅一个</strong>主题(Topic)</strong>。成功订阅后，消息服务器会将该主题下的消息转发给所有订阅者</li><li>主题(Topic)以’/‘为分隔符区分不同的层级，包含通配符’+’ 或 ‘#’的主题又称为<strong>主题过滤器(Topic Filters)</strong>; 不含通配符的成为<strong>主题名(Topic Names)</strong> 例如:</li></ul><div class="language-mqtt line-numbers-mode" data-highlighter="prismjs" data-ext="mqtt"><pre><code class="language-mqtt"><span class="line">sensor/10/temperature</span>
<span class="line">sensor/+/temperature</span>
<span class="line">$SYS/broker/metrics/packets/received</span>
<span class="line">$SYS/broker/metrics/#</span>
<span class="line"></span>
<span class="line">&#39;+&#39; : 表示通配一个层级， 例如a/+，匹配a/x, a/y</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>发布者(Publisher)只能向主题名发布消息，订阅者(Subscriber)则可以通过订阅主题过滤器来通配多个主题名称</li><li><strong>会话(Session)</strong> ：每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。</li></ul><h4 id="mqtt协议中的方法" tabindex="-1"><a class="header-anchor" href="#mqtt协议中的方法"><span>MQTT协议中的方法</span></a></h4><p>MQTT协议中定义了一些方法(也被称为动作)，表示对确定资源进行操作。这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。通常来说，资源指服务器上的文件或输出的主要方法有:</p><ol><li>CONNECT: 客户端连接到服务器</li><li>CONNACK: 连接确认</li><li>PUBLISH: 发布消息</li><li>PUBACK: 发布消息确认</li><li>PUBREC: 发布的消息已接收</li><li>PUBREL: 发布的消息已释放</li><li>PUBCOMP: 发布完成</li><li>SUBSCRIBE: 订阅请求</li><li>SUBACK: 订阅确认</li><li>UNSUBSCRIBE: 取消订阅</li><li>UNSUBACK: 取消订阅确认</li><li>PINGREQ: 客户端发送心跳</li><li>PINGRESP: 服务端心跳响应</li><li>DISCONNECT: 断开连接</li><li>AUTH: 认证</li></ol><h3 id="数据包结构" tabindex="-1"><a class="header-anchor" href="#数据包结构"><span>## 数据包结构</span></a></h3><p>在MQTT协议中，一个MQTT数据包由: 固定头(Fixed header)、可变头(Variable header)、消息体(payload)三部分构成。 <img src="`+T+'" alt=""><img src="'+b+'" alt=""></p><ol><li>固定头(Fixed header)。存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识，如连接，发布，订阅，心跳等。其中固定头是必须的，所有类型的MQTT协议中，都必须包含固定头。</li><li>可变头(Variable header)。存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。可变头部不是可选的意思，而是指这部分在有些协议类型中存在，在有些协议中不存在。</li><li>消息体（Payload)。存在于部分MQTT数据包中，表示客户端收到的具体内容。与可变头一样,在有些协议类型中有消息内容，有些协议类型中没有消息内容。</li></ol><h4 id="固定头" tabindex="-1"><a class="header-anchor" href="#固定头"><span>固定头</span></a></h4><p><img src="'+g+'" alt=""></p><ul><li><p>固定头存在于所有MQTT数据包中，固定头包含两部分内容：</p><ol><li>首字节(字节1)</li><li>剩余消息报文长度(从第二个字节开始，长度为1-4字节)。</li></ol></li><li><p>数据包类型: 第一个字节(Byte 1)中的7-4个bit位(Bit[7-4]),标识4位无符号值 <img src="'+B+'" alt=""></p></li><li><p>标志位: 第一个字节中的0-3个bit位(Bit[3-0])。字节位Bit[3-0]用作报文的标识。 <img src="'+C+'" alt=""></p></li><li><p>其中Bit[3]为DUP字段，如果该值为1，表明这个数据包是一条重复的消息；否则该数据包就是第一次发布的消息</p></li><li><p>Bit[2-1]为QoS字段:</p><ul><li>如果Bit 1 和 Bit 2都为0，表示QoS 0: 至多一次；</li><li>如果Bit 1为1, 表示QoS 1: 至少一次；</li><li>如果Bit 2为1，表示QoS 2：只有一次；</li><li>如果同时将Bit 1 和 Bit 2都设置成1，那么客户端或服务器认为这是一条非法的消息，会关闭当前连接。</li></ul></li><li><p>QoS: 服务质量是指 客户端和服务端之间的服务质量</p></li><li><p>MQTT消息的QoS ：MQTT发布消息服务质量保证(QoS)不是端到端的，是客户端与服务端之间的。订阅者收到MQTT消息的QoS级别，最终取决于发布消息的QoS和主题订阅的QoS <img src="'+u+'" alt=""></p></li><li><p>QoS消息订阅(至多一次): <img src="'+P+'" alt=""></p></li><li><p>QoS1消息发布订阅(至少一次) <img src="'+A+'" alt=""></p></li><li><p>QoS2消息发布订阅(只有一次) <img src="'+S+'" alt=""></p></li></ul><h4 id="可变头" tabindex="-1"><a class="header-anchor" href="#可变头"><span>可变头</span></a></h4><ul><li>可变头的意思是可变化的消息头部。有些报文类型包含可变头部有些报文则不包含。可变头部在固定头部和消息内容之间，其内容根据报文类型不同而不同</li></ul><h4 id="消息体" tabindex="-1"><a class="header-anchor" href="#消息体"><span>消息体</span></a></h4><ul><li>有些报文类型是包含Payload(消息载体)，如PUBLISH的Payload就是指消息内容(应用程序发布的消息内容)。而CONNECT的Payload则包含Client Identifier, Will Topic, Will Message, Username, Password等信息。</li><li>Payload只在某些报文类型中出现，其内容和格式也根据报文类型不同而不同</li></ul><p><img src="'+m+'" alt="600"></p>',92)]))}const D=i(_,[["render",f]]),M=JSON.parse('{"path":"/guide/knowledge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html","title":"计算机网络","lang":"zh-CN","frontmatter":{},"git":{},"filePathRelative":"guide/knowledge/计算机网络.md"}');export{D as comp,M as data};
