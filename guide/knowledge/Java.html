<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.23" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <link rel="icon" href="yr.ico"><title>Java | Yanranのblog</title><meta name="description" content="Yanranのblog">
    <link rel="preload" href="/Yanran_blog/assets/style-C2JCxPSn.css" as="style"><link rel="stylesheet" href="/Yanran_blog/assets/style-C2JCxPSn.css">
    <link rel="modulepreload" href="/Yanran_blog/assets/app-ZTDKGR0h.js"><link rel="modulepreload" href="/Yanran_blog/assets/Java.html-BIL7JSOz.js">
    <link rel="prefetch" href="/Yanran_blog/assets/index.html-z5vKWrMT.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/homepage0.html-DvknYbGJ.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/a.html-B0bByQLq.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/科研学术.html-DLRqRIxT.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/网址集合.html-A2a7v20C.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/软件工具.html-DAV81I82.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/a.html-Cn2njCxc.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/a.html-T13twuop.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/C__基础.html-B6_21a_Q.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/C__基础入门.html-BNefRxdm.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/C__提高编程.html-CgK2wMCy.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/C__核心编程.html-Db-8XKra.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/Git.html-tlQiM7sJ.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/Linux基础.html-Bo4kuLvI.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/MFC.html-B5o_Lsiu.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/Qt.html-v5hSCP2H.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/Thead.html-Cye-Oivh.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/Vue.html-B8p80yEB.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/操作系统.html-Cd4rQuU5.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/数据结构.html-BtQdLjRB.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/计算机基础.html-DhT6_JNJ.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/计算机编译.html-Jl317HP7.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/计算机网络.html-BU3RRpBC.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/404.html-CTZ_eyDD.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/Yanran_blog/"><img class="vp-site-logo" src="/Yanran_blog/yr.ico" alt="Yanranのblog"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">Yanranのblog</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/Yanran_blog/guide/homepage/homepage0.html" aria-label="主页"><!--[--><!--[--><!--]--><!--]-->主页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Yanran_blog/guide/knowledge/a.html" aria-label="知识学习"><!--[--><!--[--><!--]--><!--]-->知识学习<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Yanran_blog/guide/tool/a.html" aria-label="工具积累"><!--[--><!--[--><!--]--><!--]-->工具积累<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Yanran_blog/guide/other/a.html" aria-label="其他"><!--[--><!--[--><!--]--><!--]-->其他<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/yanran425/Yanran_blog.git" aria-label="GitHub" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->GitHub<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/Yanran_blog/guide/homepage/homepage0.html" aria-label="主页"><!--[--><!--[--><!--]--><!--]-->主页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Yanran_blog/guide/knowledge/a.html" aria-label="知识学习"><!--[--><!--[--><!--]--><!--]-->知识学习<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Yanran_blog/guide/tool/a.html" aria-label="工具积累"><!--[--><!--[--><!--]--><!--]-->工具积累<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Yanran_blog/guide/other/a.html" aria-label="其他"><!--[--><!--[--><!--]--><!--]-->其他<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/yanran425/Yanran_blog.git" aria-label="GitHub" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->GitHub<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading active">知识学习 <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/a.html" aria-label="README"><!--[--><!--[--><!--]--><!--]-->README<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/C__%E5%9F%BA%E7%A1%80.html" aria-label="C++基础"><!--[--><!--[--><!--]--><!--]-->C++基础<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/C__%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.html" aria-label="C++基础入门"><!--[--><!--[--><!--]--><!--]-->C++基础入门<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/C__%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B.html" aria-label="C++提高编程"><!--[--><!--[--><!--]--><!--]-->C++提高编程<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/C__%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B.html" aria-label="C++核心编程"><!--[--><!--[--><!--]--><!--]-->C++核心编程<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/Git.html" aria-label="Git"><!--[--><!--[--><!--]--><!--]-->Git<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link route-link-active auto-link vp-sidebar-item active" href="/Yanran_blog/guide/knowledge/Java.html" aria-label="Java"><!--[--><!--[--><!--]--><!--]-->Java<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/Linux%E5%9F%BA%E7%A1%80.html" aria-label="Linux基础"><!--[--><!--[--><!--]--><!--]-->Linux基础<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/MFC.html" aria-label="MFC"><!--[--><!--[--><!--]--><!--]-->MFC<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/Qt.html" aria-label="Qt"><!--[--><!--[--><!--]--><!--]-->Qt<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/Thead.html" aria-label="多线程"><!--[--><!--[--><!--]--><!--]-->多线程<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/Vue.html" aria-label="Vue"><!--[--><!--[--><!--]--><!--]-->Vue<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html" aria-label="操作系统"><!--[--><!--[--><!--]--><!--]-->操作系统<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" aria-label="数据结构"><!--[--><!--[--><!--]--><!--]-->数据结构<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html" aria-label="计算机基础"><!--[--><!--[--><!--]--><!--]-->计算机基础<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E8%AF%91.html" aria-label="计算机编译"><!--[--><!--[--><!--]--><!--]-->计算机编译<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html" aria-label="计算机网络"><!--[--><!--[--><!--]--><!--]-->计算机网络<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div id="content"><h1 id="java" tabindex="-1"><a class="header-anchor" href="#java"><span>Java</span></a></h1><h2 id="_1-编译" tabindex="-1"><a class="header-anchor" href="#_1-编译"><span>1.编译</span></a></h2><p>在<code>JAVA_HOME</code>的<code>bin</code>目录下找到很多可执行文件：</p><ul><li>java：这个可执行程序其实就是JVM，运行Java程序，就是启动JVM，然后让JVM执行指定的编译后的代码；</li><li>javac：这是Java的编译器，它用于把Java源码文件（以<code>.java</code>后缀结尾）编译为Java字节码文件（以<code>.class</code>后缀结尾）；</li><li>jar：用于把一组<code>.class</code>文件打包成一个<code>.jar</code>文件，便于发布；</li><li>javadoc：用于从Java源码中自动提取注释并生成文档；</li><li>jdb：Java调试器，用于开发阶段的运行调试。</li></ul><hr><h2 id="_2-oop" tabindex="-1"><a class="header-anchor" href="#_2-oop"><span>2.OOP</span></a></h2><ul><li>重载(Overload):方法名相同，参数不同，返回值类型相同。</li><li>重写(Override):用于多态，子类重写父类的方法。</li><li>抽象类(abstract):必须有方法是抽象方法，不用写内容，重在规范约束，要求子类必须重写。</li><li>接口(interface):抽象类中没有字段，全部都是抽象方法，则可以改为接口。接口定义的所有方法默认都是public abstract的。一个子类可以继承多个接口。</li></ul><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">abstract class</th><th style="text-align:center;">interface</th></tr></thead><tbody><tr><td style="text-align:center;">继承</td><td style="text-align:center;">只能extends一个class</td><td style="text-align:center;">可以implements多个interface</td></tr><tr><td style="text-align:center;">字段</td><td style="text-align:center;">可以定义实例字段</td><td style="text-align:center;">不能定义实例字段</td></tr><tr><td style="text-align:center;">抽象方法</td><td style="text-align:center;">可以定义抽象方法</td><td style="text-align:center;">可以定义抽象方法</td></tr><tr><td style="text-align:center;">非抽象方法</td><td style="text-align:center;">可以定义非抽象方法</td><td style="text-align:center;">可以定义default方法</td></tr></tbody></table><ul><li>静态方法经常用于工具类</li></ul><hr><h2 id="_3-命名空间" tabindex="-1"><a class="header-anchor" href="#_3-命名空间"><span>3.命名空间</span></a></h2><h3 id="_3-1-包" tabindex="-1"><a class="header-anchor" href="#_3-1-包"><span>3.1 包</span></a></h3><ol><li>package说明</li></ol><ul><li>一个类总是属于某个包（包名.类名）</li><li>在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。</li><li>包可以是多层结构，用<code>.</code>隔开。例如：<code>java.util</code>。</li><li>位于同一个包的类，可以访问包作用域的字段和方法。</li><li>不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。</li></ul><ol start="2"><li>Java编译器最终编译出的<code>.class</code>文件只使用_完整类名_，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</li></ol><ul><li><p>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</p></li><li><p>如果是简单类名，按下面的顺序依次查找：</p><ul><li>查找当前<code>package</code>是否存在这个<code>class</code>；</li><li>查找<code>import</code>的包是否包含这个<code>class</code>；</li><li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li></ul></li><li><p>如果按照上面的规则还无法确定类名，则编译报错。</p></li></ul><ol start="3"><li>编写class的时候，编译器会自动帮我们做两个import动作：</li></ol><ul><li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</li><li>默认自动<code>import java.lang.*</code>。</li></ul><blockquote><p>[!NOTE] 包名必须完全一致，包没有父子关系，<code>com.apache</code>和<code>com.apache.abc</code>是不同的包。</p></blockquote><blockquote><p>[!INFO] 用<code>final</code>修饰<code>class</code>可以阻止被继承。用<code>final</code>修饰方法可以防止被重写。用<code>final</code>修饰字段可以防止被修改值。</p></blockquote><ol start="4"><li>Java核心类库</li></ol><ul><li>java.lang包 – 该包是Java语言的核心包，并且该包中的所有内容由Java虚拟机自动导入。如：System类、String类、…</li><li>java.util包 – 该包是Java语言的工具包，里面提供了大量工具类以及集合类等。如：Scanner类、Random类、List集合、…</li><li>java.io包 – 该包是Java语言中的输入输出包，里面提供了大量读写文件相关的类等。如：FileInputStream类、FileOutputStream类、…</li><li>java.net包 – 该包是Java语言中的网络包，里面提供了大量网络编程相关的类等。如：ServerSocket类、Socket类、…</li><li>java.sql 包 – 该包是Java语言中的数据包，里面提供了大量操作数据库的类和接口等。如：DriverManager类、Connection接口、</li></ul><h3 id="_3-2-classpath" tabindex="-1"><a class="header-anchor" href="#_3-2-classpath"><span>3.2 classpath</span></a></h3><ul><li><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code>。所以，<code>classpath</code>就是一组目录的集合，它设置的搜索路径与操作系统相关。</li><li>在IDE中运行Java程序，IDE自动传入的<code>-cp</code>参数是当前工程的<code>bin</code>目录和引入的jar包。而在命令行中应当明确指出，例如<code> java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello</code>。（<code>-cp</code>也可以写全就是<code>-classpath</code>）</li></ul><h3 id="_3-3-jar" tabindex="-1"><a class="header-anchor" href="#_3-3-jar"><span>3.3 jar</span></a></h3><ul><li>如果有很多<code>.class</code>文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。</li><li>jar包就是用来干这个事的，它可以把<code>package</code>组织的目录层级，以及各个目录下的所有文件（包括<code>.class</code>文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。<code>java -cp ./hello.jar abc.xyz.Hello</code></li></ul><blockquote><p>[!NOTE] jar只是用于存放class的容器，它并不关心class之间的依赖。</p></blockquote><h3 id="_3-4-class版本" tabindex="-1"><a class="header-anchor" href="#_3-4-class版本"><span>3.4 class版本</span></a></h3><ul><li>Java 8，Java 11，Java 17，是指JDK的版本，也就是JVM的版本，更确切地说，就是<code>java.exe</code>这个程序的版本。</li><li>Java 11对应的class文件版本是55，而Java 17对应的class文件版本是61。</li></ul><h3 id="_3-5-模块-module" tabindex="-1"><a class="header-anchor" href="#_3-5-模块-module"><span>3.5 模块（Module）</span></a></h3><ul><li><p>一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫<code>rt.jar</code>，一共有60多M。所以要运行main函数就得设置<code>classpath</code>搜索好多路径的jar包。</p></li><li><p>如果<code>a.jar</code>必须依赖另一个<code>b.jar</code>才能运行，那我们应该给<code>a.jar</code>加点说明<code>module-info.class</code>啥的，让程序在编译和运行的时候能自动定位到<code>b.jar</code>，这种自带“依赖关系”的class容器就是模块。</p></li></ul><blockquote><p>[!NOTE] 把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。</p></blockquote><hr><h2 id="_4-boxing" tabindex="-1"><a class="header-anchor" href="#_4-boxing"><span>4. Boxing</span></a></h2><p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p><table><thead><tr><th style="text-align:center;">基本类型</th><th style="text-align:center;">对应的引用类型</th></tr></thead><tbody><tr><td style="text-align:center;">boolean</td><td style="text-align:center;">java.lang.Boolean</td></tr><tr><td style="text-align:center;">byte</td><td style="text-align:center;">java.lang.Byte</td></tr><tr><td style="text-align:center;">short</td><td style="text-align:center;">java.lang.Short</td></tr><tr><td style="text-align:center;">int</td><td style="text-align:center;">java.lang.Integer</td></tr><tr><td style="text-align:center;">long</td><td style="text-align:center;">java.lang.Long</td></tr><tr><td style="text-align:center;">float</td><td style="text-align:center;">java.lang.Float</td></tr><tr><td style="text-align:center;">double</td><td style="text-align:center;">java.lang.Double</td></tr><tr><td style="text-align:center;">char</td><td style="text-align:center;">java.lang.Character</td></tr></tbody></table><blockquote><p>[!NOTE] 所有的包装类型都是不变类。<code>BigInteger</code>和<code>Integer</code>、<code>Long</code>一样，也是不可变类，总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！</p></blockquote><h2 id="_5-enum" tabindex="-1"><a class="header-anchor" href="#_5-enum"><span>5. Enum</span></a></h2><p><code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点：</p><ul><li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li><li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li><li>定义的每个实例都是引用类型的唯一实例；</li><li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li></ul><hr><h2 id="_6-exception" tabindex="-1"><a class="header-anchor" href="#_6-exception"><span>6. Exception</span></a></h2><ol><li>Java标准库定义的常用异常包括：</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">Exception</span>
<span class="line">├─ RuntimeException</span>
<span class="line">│  ├─ NullPointerException(NPE)</span>
<span class="line">│  ├─ IndexOutOfBoundsException</span>
<span class="line">│  ├─ SecurityException</span>
<span class="line">│  └─ IllegalArgumentException</span>
<span class="line">│     └─ NumberFormatException</span>
<span class="line">├─ IOException</span>
<span class="line">│  ├─ UnsupportedCharsetException</span>
<span class="line">│  ├─ FileNotFoundException</span>
<span class="line">│  └─ SocketException</span>
<span class="line">├─ ParseException</span>
<span class="line">├─ GeneralSecurityException</span>
<span class="line">├─ SQLException</span>
<span class="line">└─ TimeoutException</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>Java中Logging模块定义了7个等级，默认是INFO</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line"> SEVERE</span>
<span class="line"> WARNING</span>
<span class="line"> INFO</span>
<span class="line"> CONFIG</span>
<span class="line"> FINE</span>
<span class="line"> FINER</span>
<span class="line"> FINES</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>Commons Logging定义了6个日志级别，默认级别是INFO。</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">FATAL</span>
<span class="line">ERROR</span>
<span class="line">WARNING</span>
<span class="line">INFO</span>
<span class="line">DEBUG</span>
<span class="line">TRACE</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>对比Commons Logging和SLF4J的接口：</li></ol><table><thead><tr><th>Commons Logging</th><th>SLF4J</th></tr></thead><tbody><tr><td>org.apache.commons.logging.Log</td><td>org.slf4j.Logger</td></tr><tr><td>org.apache.commons.logging.LogFactory</td><td>org.slf4j.LoggerFactory</td></tr><tr><td>## 7. Reflection</td><td></td></tr></tbody></table><ol><li>基础定义</li></ol><ul><li><p>反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。</p></li><li><p>反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p></li><li><p>除了int等基本类型外，Java的其他类型全部都是class（包括interface）。</p></li><li><p>class（包括interface）的本质是数据类型（Type）。无继承关系的数据类型无法赋值</p></li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">Number n = new Double(123.456); // OK\</span>
<span class="line">String s = new Double(123.456); // compile error!\</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。</li><li>这种通过Class实例获取class信息的方法称为反射（Reflection）。</li></ul><blockquote><p>[!Note] 每个类（class）或者基本数据类型（e.g.,int）都是一种数据类型（Type）。</p></blockquote><blockquote><p>[!Note] 其中Java为每个类（class）都创建了一个实例（Class），这个实例与其他实例不同，它的实例类型是Class类型，这个实例记录了class的完整信息。</p></blockquote><h2 id="_8-maven" tabindex="-1"><a class="header-anchor" href="#_8-maven"><span>8. Maven</span></a></h2><h3 id="_8-1-基础配置" tabindex="-1"><a class="header-anchor" href="#_8-1-基础配置"><span>8.1 基础配置</span></a></h3><ul><li>本地仓库地址路径的配置</li><li>下载包与插件时的镜像源的配置</li><li>指定javajdk版本的配置</li></ul><h3 id="_8-2-maven指令" tabindex="-1"><a class="header-anchor" href="#_8-2-maven指令"><span>8.2 Maven指令</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">mvn compile</span>
<span class="line">mvn clean</span>
<span class="line">mvn test</span>
<span class="line">mvn package</span>
<span class="line">mvn install</span>
<span class="line"></span>
<span class="line">mvn aechetype:generate</span>
<span class="line">	-DgroupId={project-packaging}</span>
<span class="line">	-DartifactId={project-name}</span>
<span class="line">	-DarchetypeArtifactId=maven-archetype-quickstart</span>
<span class="line">	-DubteractiveMode=false</span>
<span class="line"></span>
<span class="line">//创建Java工程</span>
<span class="line">mvn archetype:generate -DgroupId=com.demo -DartifactId=java-project -DarchetypeArtifactId=maven-archetype-quickstart -Dversion=0.0.1-snapshot -DinteractiveMode=false</span>
<span class="line">//创建Web工程</span>
<span class="line">mvn archetype:generate -DgroupId=com.demo -DartifactId=web-project -DarchetypeArtifactId=maven-archetype-webapp -Dversion=0.0.1-snapshot -DinteractiveMode=false</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_8-3-maven工程结构" tabindex="-1"><a class="header-anchor" href="#_8-3-maven工程结构"><span>8.3 Maven工程结构</span></a></h3><p><img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-Bhf5aM4Z.png" alt=""><img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-1-iPxCGMFy.png" alt=""></p><h3 id="_8-4-maven依赖范围" tabindex="-1"><a class="header-anchor" href="#_8-4-maven依赖范围"><span>8.4 Maven依赖范围</span></a></h3><p><img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-2-ieRhTKnK.png" alt=""><img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-3-C6dbUk4I.png" alt=""></p><h3 id="_8-5-maven主要功能" tabindex="-1"><a class="header-anchor" href="#_8-5-maven主要功能"><span>8.5 Maven主要功能</span></a></h3><ol><li>提供了一套标准化的项目结构</li><li>提供了一套标准化的构建流程（编译，测试，打包，发布）</li><li>提供了一套依赖管理机制</li></ol><h3 id="_8-6-maven模型" tabindex="-1"><a class="header-anchor" href="#_8-6-maven模型"><span>8.6 Maven模型</span></a></h3><p><img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-4-D32EtgVi.png" alt=""></p><h2 id="_9-spring" tabindex="-1"><a class="header-anchor" href="#_9-spring"><span>9. Spring</span></a></h2><h3 id="_9-1-spring体系结构" tabindex="-1"><a class="header-anchor" href="#_9-1-spring体系结构"><span>9.1 Spring体系结构</span></a></h3><ul><li>Spring是分层的JavaSE/EE应用full-stack轻量级开源框架，以IoC(Inverse Of Control:反转控制)和AOP(Aspect Oriented Programming:面向切面编程)为内核。</li><li><img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-5-CF7NofQD.png" alt=""></li></ul><h3 id="_9-2-spring的开发示例" tabindex="-1"><a class="header-anchor" href="#_9-2-spring的开发示例"><span>9.2 Spring的开发示例</span></a></h3><ol><li>开发原理 <img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-6-D25FI29m.png" alt=""></li><li>开发流程 <img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-7-DtvH1eBy.png" alt=""></li></ol><blockquote><p>[!note] 第4步，Spring配置文件通常取名为“applicationContext.xml”。</p></blockquote><blockquote><p>[!note] 配置Bean标签，参数有id，class，scope，init-method，destroy-method.</p></blockquote><ol start="3"><li><p>scope配置的意义 <img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-8-CKm7M898.png" alt=""></p></li><li><p>Bean实例化的方式 - 无参构造方法 - 工厂静态方法 - 工厂实例方法</p></li></ol><h3 id="_9-3-依赖注入" tabindex="-1"><a class="header-anchor" href="#_9-3-依赖注入"><span>9.3 依赖注入</span></a></h3><ol><li>Bean的依赖注入（Dependency Injection，它是Spring框架核心IOC的具体实现）</li><li>注入方法</li></ol><ul><li><p>set方法注入</p></li><li><p>构造方法注入</p></li></ul><ol start="3"><li>注入类型</li></ol><ul><li>普通数据类型</li><li>引用注入类型</li><li>集合数据类型</li></ul><ol start="4"><li>配置文件</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">&lt;bean&gt; 标签</span>
<span class="line">	id 属性 ： 在容器中Bean实例的唯一标识，不允许重复</span>
<span class="line">	class属性：要实例化的Bean的全限定名（也叫全包名）</span>
<span class="line">	scope属性：Bean的作用范围，常用是singleton（默认）和prototype</span>
<span class="line">	&lt;property&gt;标签：属性注入</span>
<span class="line">		name属性：属性名称</span>
<span class="line">		value属性：注入的普通属性值</span>
<span class="line">		ref属性：注入的对象引用值</span>
<span class="line">		&lt;list&gt;标签</span>
<span class="line">		&lt;map&gt;标签</span>
<span class="line">		&lt;properties&gt;标签</span>
<span class="line">	&lt;constructor-arg&gt;标签</span>
<span class="line">&lt;import&gt;标签：导入其他的Spring的分文件</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-4-application-context" tabindex="-1"><a class="header-anchor" href="#_9-4-application-context"><span>9.4 Application Context</span></a></h3><p><img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-10-DL5OoZzC.png" alt=""></p><h3 id="_9-5-注解开发" tabindex="-1"><a class="header-anchor" href="#_9-5-注解开发"><span>9.5 注解开发</span></a></h3><ol><li>原始注解 <img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-11-BVtM6rU3.png" alt=""><img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-12-Bn24LL-e.png" alt=""> Autowired 和 Qualifier进行set注入的时候可以不需要写set方法；使用xml配置时需要写set方法。</li><li>新注解 <img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-13-DebVP5sT.png" alt=""></li></ol><h3 id="_9-6-springjunit" tabindex="-1"><a class="header-anchor" href="#_9-6-springjunit"><span>9.6 SpringJunit</span></a></h3><ul><li>Spring每次测试都需要先创建容器，然后再拿到bean进行测试，否则会出现空指针。</li><li>因此 <ul><li>让SpringJunit负责创建Spring容器</li><li>将需要测试的Bean直接在测试类中进行注入</li><li></li></ul></li></ul><h2 id="_10-javaweb" tabindex="-1"><a class="header-anchor" href="#_10-javaweb"><span>10 JavaWeb</span></a></h2><h3 id="_10-1-简介" tabindex="-1"><a class="header-anchor" href="#_10-1-简介"><span>10.1 简介</span></a></h3><ol><li>关系 <img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-14-Bxj3rmpz.png" alt=""></li><li>内容 1. 数据库：MySQL，JDBC，MyBatis 2. 前端：HTML+CSS，JS，Ajax+Vue+ElementUI 3. Web核心：Tomcat+HTTP+Servlet，Request+Response，JSP，Cookie+Session，Filter+Listener</li><li>数据库查询 <img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-15-DovwfQD4.png" alt=""></li></ol><h3 id="_10-2-jdbc" tabindex="-1"><a class="header-anchor" href="#_10-2-jdbc"><span>10.2 JDBC</span></a></h3><ol><li>JDBC就是使用JAVA语言操作关系型数据库的一套API <img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-16-CiQ5y6Rc.png" alt=""></li><li>逻辑 <img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-17-BTdjHXN4.png" alt=""></li><li>预防SQL注入 <img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-18-B4YHPI1T.png" alt=""></li><li>抽取<code>jdbc</code>配置文件 <img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-19-DgWhLMz8.png" alt=""></li><li>缺点 <img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-20-DZDRN9PP.png" alt=""></li></ol><h3 id="_10-3-数据源-连接池" tabindex="-1"><a class="header-anchor" href="#_10-3-数据源-连接池"><span>10.3 数据源（连接池）</span></a></h3><ul><li><p>常见的数据源：DBCP、C3P0、BoneCP、Druid</p></li><li><p>数据库连接池是个容器，负责分配、管理数据库连接（Connection）</p></li><li><p>数据库连接池允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</p></li><li><p>优势</p><ul><li>资源重用</li><li>提升系统相应速度</li><li>避免数据库连接遗漏</li></ul></li><li><p>数据源开发步骤：</p><ol><li>导入数据源的坐标和驱动坐标</li><li>创建数据源的对象</li><li>设置数据源的基本连接数据（账号、密码）</li><li>获取连接资源和归还连接资源</li></ol></li><li><p>图示 <img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-21-BustxfTu.png" alt=""></p></li><li><p>数据库连接池的标准接口实现：DataSource</p></li><li><p>增删改查数据 <img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-22-DhyJvkaA.png" alt=""></p></li></ul><h2 id="_11-mybatis" tabindex="-1"><a class="header-anchor" href="#_11-mybatis"><span>11 MyBatis</span></a></h2><h3 id="_11-1-mybatis是什么" tabindex="-1"><a class="header-anchor" href="#_11-1-mybatis是什么"><span>11.1 MyBatis是什么</span></a></h3><ul><li>MyBatis是一款持久层框架，用于简化JDBC开发</li><li>持久层是负责将数据保存到数据库的那一层代码</li></ul><blockquote><p>[!Note] JaveEE的三层架构：表现层、业务层、持久层</p></blockquote><h3 id="_11-2-mabatis简化" tabindex="-1"><a class="header-anchor" href="#_11-2-mabatis简化"><span>11.2 MaBatis简化</span></a></h3><ol start="6"><li>处理JDBC连接过程的硬编码问题：配置文件</li><li>处理JDBC连接过程的操作繁琐问题：自动完成</li></ol><blockquote><p>[!Summary] MyBatis免除了几乎所有的JDBC代码以及设置参数和获取结果集的工作</p></blockquote><h3 id="_11-3-mapper代理开发" tabindex="-1"><a class="header-anchor" href="#_11-3-mapper代理开发"><span>11.3 Mapper代理开发</span></a></h3><ul><li>目的 <ol><li>解决原生方式中的硬编码</li><li>简化后期执行SQL</li></ol></li><li>图示 <img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-23-tvX8N0pf.png" alt=""></li><li>步骤要求 <img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-24-BXkrTWvr.png" alt=""></li></ul><h3 id="_11-4-mybatis核心配置文件" tabindex="-1"><a class="header-anchor" href="#_11-4-mybatis核心配置文件"><span>11.4 MyBatis核心配置文件</span></a></h3><p><img src="/Yanran_blog/assets/Java%E5%9F%BA%E7%A1%80-25-D8cHxaPs.png" alt=""></p></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav" aria-label="page navigation"><a class="route-link auto-link prev" href="/Yanran_blog/guide/knowledge/Git.html" aria-label="Git"><!--[--><div class="hint"><span class="arrow left"></span> Prev</div><div class="link"><span class="external-link">Git</span></div><!--]--></a><a class="route-link auto-link next" href="/Yanran_blog/guide/knowledge/Linux%E5%9F%BA%E7%A1%80.html" aria-label="Linux基础"><!--[--><div class="hint">Next <span class="arrow right"></span></div><div class="link"><span class="external-link">Linux基础</span></div><!--]--></a></nav><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/Yanran_blog/assets/app-ZTDKGR0h.js" defer></script>
  </body>
</html>
