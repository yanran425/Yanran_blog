<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.23" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <link rel="icon" href="yr.ico"><title>操作系统 | Yanranのblog</title><meta name="description" content="Yanranのblog">
    <link rel="preload" href="/Yanran_blog/assets/style-C2JCxPSn.css" as="style"><link rel="stylesheet" href="/Yanran_blog/assets/style-C2JCxPSn.css">
    <link rel="modulepreload" href="/Yanran_blog/assets/app-ZTDKGR0h.js"><link rel="modulepreload" href="/Yanran_blog/assets/操作系统.html-Cd4rQuU5.js">
    <link rel="prefetch" href="/Yanran_blog/assets/index.html-z5vKWrMT.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/homepage0.html-DvknYbGJ.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/a.html-B0bByQLq.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/科研学术.html-DLRqRIxT.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/网址集合.html-A2a7v20C.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/软件工具.html-DAV81I82.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/a.html-Cn2njCxc.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/a.html-T13twuop.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/C__基础.html-B6_21a_Q.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/C__基础入门.html-BNefRxdm.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/C__提高编程.html-CgK2wMCy.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/C__核心编程.html-Db-8XKra.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/Git.html-tlQiM7sJ.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/Java.html-BIL7JSOz.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/Linux基础.html-Bo4kuLvI.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/MFC.html-B5o_Lsiu.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/Qt.html-v5hSCP2H.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/Thead.html-Cye-Oivh.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/Vue.html-B8p80yEB.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/数据结构.html-BtQdLjRB.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/计算机基础.html-DhT6_JNJ.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/计算机编译.html-Jl317HP7.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/计算机网络.html-BU3RRpBC.js" as="script"><link rel="prefetch" href="/Yanran_blog/assets/404.html-CTZ_eyDD.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/Yanran_blog/"><img class="vp-site-logo" src="/Yanran_blog/yr.ico" alt="Yanranのblog"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">Yanranのblog</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/Yanran_blog/guide/homepage/homepage0.html" aria-label="主页"><!--[--><!--[--><!--]--><!--]-->主页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Yanran_blog/guide/knowledge/a.html" aria-label="知识学习"><!--[--><!--[--><!--]--><!--]-->知识学习<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Yanran_blog/guide/tool/a.html" aria-label="工具积累"><!--[--><!--[--><!--]--><!--]-->工具积累<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Yanran_blog/guide/other/a.html" aria-label="其他"><!--[--><!--[--><!--]--><!--]-->其他<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/yanran425/Yanran_blog.git" aria-label="GitHub" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->GitHub<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/Yanran_blog/guide/homepage/homepage0.html" aria-label="主页"><!--[--><!--[--><!--]--><!--]-->主页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Yanran_blog/guide/knowledge/a.html" aria-label="知识学习"><!--[--><!--[--><!--]--><!--]-->知识学习<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Yanran_blog/guide/tool/a.html" aria-label="工具积累"><!--[--><!--[--><!--]--><!--]-->工具积累<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/Yanran_blog/guide/other/a.html" aria-label="其他"><!--[--><!--[--><!--]--><!--]-->其他<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/yanran425/Yanran_blog.git" aria-label="GitHub" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->GitHub<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading active">知识学习 <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/a.html" aria-label="README"><!--[--><!--[--><!--]--><!--]-->README<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/C__%E5%9F%BA%E7%A1%80.html" aria-label="C++基础"><!--[--><!--[--><!--]--><!--]-->C++基础<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/C__%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.html" aria-label="C++基础入门"><!--[--><!--[--><!--]--><!--]-->C++基础入门<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/C__%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B.html" aria-label="C++提高编程"><!--[--><!--[--><!--]--><!--]-->C++提高编程<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/C__%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B.html" aria-label="C++核心编程"><!--[--><!--[--><!--]--><!--]-->C++核心编程<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/Git.html" aria-label="Git"><!--[--><!--[--><!--]--><!--]-->Git<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/Java.html" aria-label="Java"><!--[--><!--[--><!--]--><!--]-->Java<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/Linux%E5%9F%BA%E7%A1%80.html" aria-label="Linux基础"><!--[--><!--[--><!--]--><!--]-->Linux基础<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/MFC.html" aria-label="MFC"><!--[--><!--[--><!--]--><!--]-->MFC<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/Qt.html" aria-label="Qt"><!--[--><!--[--><!--]--><!--]-->Qt<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/Thead.html" aria-label="多线程"><!--[--><!--[--><!--]--><!--]-->多线程<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/Vue.html" aria-label="Vue"><!--[--><!--[--><!--]--><!--]-->Vue<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link route-link-active auto-link vp-sidebar-item active" href="/Yanran_blog/guide/knowledge/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html" aria-label="操作系统"><!--[--><!--[--><!--]--><!--]-->操作系统<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" aria-label="数据结构"><!--[--><!--[--><!--]--><!--]-->数据结构<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html" aria-label="计算机基础"><!--[--><!--[--><!--]--><!--]-->计算机基础<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E8%AF%91.html" aria-label="计算机编译"><!--[--><!--[--><!--]--><!--]-->计算机编译<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/Yanran_blog/guide/knowledge/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html" aria-label="计算机网络"><!--[--><!--[--><!--]--><!--]-->计算机网络<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div id="content"><h1 id="操作系统" tabindex="-1"><a class="header-anchor" href="#操作系统"><span>操作系统</span></a></h1><h2 id="ipc" tabindex="-1"><a class="header-anchor" href="#ipc"><span>IPC</span></a></h2><ul><li>进程间通信（IPC，Inter-Process Communication）是操作系统中多个进程交换数据、协同工作的核心机制。不同的 IPC 方式适用于不同的场景，其设计原理、性能和适用范围差异较大。</li><li>常见进程间通信方式及原理如下</li></ul><h3 id="_1-管道-pipe-与命名管道-fifo" tabindex="-1"><a class="header-anchor" href="#_1-管道-pipe-与命名管道-fifo"><span>1.管道（Pipe）与命名管道（FIFO）</span></a></h3><ul><li>原理：管道是内核中的一段环形缓冲区，通过 “读 / 写” 操作实现进程间字节流传递，本质是 “文件描述符” 的抽象。</li></ul><ol><li>匿名管道（Pipe）：仅用于父子进程或亲缘进程（如 fork 创建的子进程），生命周期随进程结束而销毁，无文件名，通过pipe()系统调用创建。</li><li>命名管道（FIFO）：可用于非亲缘进程，通过文件系统中的路径（如/tmp/myfifo）标识，生命周期独立于进程，通过mkfifo()创建，读写方式与文件一致。</li></ol><ul><li>实际应用</li></ul><ol><li>匿名管道：Shell 中的管道命令（如ls -l | grep .txt），父进程（ls）写入数据，子进程（grep）读取，实现命令协作。</li><li>命名管道：本地服务间的简单通信，如日志收集（应用进程写入日志到 FIFO，日志进程从 FIFO 读取并存储）。</li><li>典型场景：轻量、单向、低延迟的本地进程通信，无需跨网络。</li></ol><h3 id="_2-消息队列-message-queue" tabindex="-1"><a class="header-anchor" href="#_2-消息队列-message-queue"><span>2.消息队列（Message Queue）</span></a></h3><ul><li>原理：内核维护的消息链表，进程可按 “类型” 发送 / 接收消息（消息包含类型和数据），支持异步通信，无需进程同步等待。</li></ul><ol start="4"><li>发送方通过msgsnd()将消息放入队列，接收方通过msgrcv()按类型提取消息（可过滤特定类型）。</li><li>消息有大小限制（通常几 KB），队列总容量有限制。</li></ol><ul><li>实际应用</li></ul><ol start="6"><li>分布式任务调度：如公司内部的任务分配系统（调度进程向队列发送任务， Worker 进程按类型领取任务）。</li><li>异步通知：电商订单系统中，支付进程完成后向消息队列发送 “支付成功” 消息，物流进程监听并处理。</li></ol><ul><li>局限性：不适合高频、大数据量场景（性能低于共享内存），目前逐步被分布式消息中间件（如 RabbitMQ）替代。</li></ul><h3 id="_3-共享内存-shared-memory" tabindex="-1"><a class="header-anchor" href="#_3-共享内存-shared-memory"><span>3.共享内存（Shared Memory）</span></a></h3><ul><li>原理：多个进程将同一块物理内存映射到各自的虚拟地址空间，直接读写内存实现通信，是速度最快的 IPC 方式（无需内核中转数据）。</li></ul><ol start="8"><li>需配合同步机制（如信号量）防止并发读写冲突。</li><li>通过shmget()（创建）、shmat()（映射到进程）等系统调用实现。</li></ol><ul><li>实际应用</li></ul><ol start="10"><li>高频实时数据交换：金融交易系统（如股票行情推送，行情服务器将实时价格写入共享内存，多个交易进程直接读取，延迟 &lt; 1ms）。</li><li>大型数据共享：视频处理软件（如 Adobe Premiere，多个滤镜进程共享同一视频帧数据，避免数据拷贝）。</li><li>典型公司：高频交易公司（如 Jump Trading）、实时渲染引擎（如 Unity 引擎的多进程渲染）。</li></ol><h3 id="_4-信号量-semaphore" tabindex="-1"><a class="header-anchor" href="#_4-信号量-semaphore"><span>4.信号量（Semaphore）</span></a></h3><ul><li>原理：内核维护的计数器，用于控制多个进程对共享资源的访问（同步 / 互斥），本身不传递数据，仅用于 “权限控制”。</li></ul><ol><li>P 操作：计数器 - 1，若计数器 &lt; 0 则阻塞进程（等待资源）。</li><li>V 操作：计数器 + 1，若有进程阻塞则唤醒一个。</li><li>常用于保护共享内存、消息队列等资源的并发访问。</li></ol><ul><li>实际应用</li></ul><ol start="4"><li>共享资源互斥：多进程读写同一数据库文件时，通过信号量保证 “同一时间只有一个进程写入”。</li><li>生产者 - 消费者模型：如电商库存系统（生产者进程增加库存，消费者进程减少库存，信号量控制库存不为负）。</li></ol><h3 id="_5-信号-signal" tabindex="-1"><a class="header-anchor" href="#_5-信号-signal"><span>5.信号（Signal）</span></a></h3><ul><li>原理：操作系统向进程发送的异步事件通知（类似 “软件中断”），可携带极少信息（仅信号编号），用于触发进程预设的处理函数。</li></ul><ol start="6"><li>常见信号：SIGINT（Ctrl+C 终止）、SIGKILL（强制杀死进程）、SIGCHLD（子进程退出通知）。</li><li>进程通过signal()或sigaction()注册信号处理函数。</li></ol><ul><li>实际应用</li></ul><ol start="8"><li>异常处理：进程崩溃时通过SIGSEGV（段错误）捕获并记录日志（如 Linux 的 core dump）。</li><li>进程控制：父进程通过SIGTERM优雅终止子进程（子进程收到后释放资源再退出）。</li><li>典型场景：简单的事件通知（如进程退出、超时提醒），不适合传递复杂数据。</li></ol><h3 id="_6-套接字-socket" tabindex="-1"><a class="header-anchor" href="#_6-套接字-socket"><span>6.套接字（Socket）</span></a></h3><ul><li>原理：基于网络协议栈的通信机制，支持同一主机或跨网络的进程通信，通过 “IP 地址 + 端口” 标识进程，支持 TCP（可靠流）和 UDP（不可靠报）协议。</li></ul><ol start="11"><li>本地套接字（Unix Domain Socket）：用于同一主机进程，通过文件系统路径标识（如/var/run/mysocket），性能优于网络套接字。</li><li>网络套接字：用于跨主机通信，如互联网服务。</li></ol><ul><li>实际应用</li></ul><ol start="13"><li>跨主机通信：所有互联网服务（如浏览器与 Web 服务器通过 TCP 通信，即时通讯工具如微信用 UDP 传输语音）。</li><li>本地高可靠通信：数据库客户端与服务端（如 MySQL 客户端通过本地 Socket 连接服务器，避免网络开销）。</li><li>典型公司：腾讯（微信消息传输）、阿里（分布式服务间调用）、谷歌（跨数据中心通信）。</li></ol><h3 id="_7-文件映射-memory-mapped-file" tabindex="-1"><a class="header-anchor" href="#_7-文件映射-memory-mapped-file"><span>7.文件映射（Memory-Mapped File）</span></a></h3><ul><li>原理：将磁盘文件映射到进程的虚拟内存，进程读写内存即等效于读写文件，多进程映射同一文件可实现共享数据。</li></ul><ol start="16"><li>原理类似共享内存，但数据持久化到磁盘，适合大数据量（GB 级）共享。</li></ol><ul><li>实际应用</li></ul><ol start="17"><li>大型文件处理：视频编辑软件（如 Final Cut Pro）映射 4K 视频文件到内存，多进程（解码、渲染）直接操作内存数据。</li><li>数据库存储：SQLite 通过文件映射实现高效的磁盘 IO，避免频繁的read()/write()系统调用。</li></ol><h2 id="主流-ipc-方式及适用场景" tabindex="-1"><a class="header-anchor" href="#主流-ipc-方式及适用场景"><span>主流 IPC 方式及适用场景</span></a></h2><table><thead><tr><th><strong>场景</strong></th><th><strong>主流方式</strong></th><th><strong>核心技术 / 库</strong></th><th><strong>典型业务</strong></th></tr></thead><tbody><tr><td>本地轻量通信</td><td>命名管道（FIFO）、本地 Socket</td><td><code>mkfifo()</code>、<code>socket(AF_UNIX)</code>、Qt 的<code>QLocalSocket</code></td><td>日志收集、桌面应用插件通信</td></tr><tr><td>高频实时数据交换</td><td>共享内存 + 信号量</td><td>System V 共享内存、<code>boost::interprocess</code></td><td>金融行情、实时渲染</td></tr><tr><td>跨网络 / 跨主机通信</td><td>网络 Socket（TCP/UDP）</td><td>BSD Socket、<code>Boost.Asio</code>、Qt 的<code>QTcpSocket</code></td><td>互联网服务、分布式系统</td></tr><tr><td>异步消息传递</td><td>消息队列（分布式中间件）</td><td>RabbitMQ、Kafka（基于 Socket 封装）</td><td>电商订单、日志异步处理</td></tr><tr><td>简单事件通知</td><td>信号（Signal）</td><td><code>sigaction()</code>、Qt 的<code>QProcess::errorOccurred</code></td><td></td></tr></tbody></table><h2 id="ipc-c-原生及标准库" tabindex="-1"><a class="header-anchor" href="#ipc-c-原生及标准库"><span>IPC-C++原生及标准库</span></a></h2><ul><li>管道 / 命名管道：通过pipe()（匿名）、mkfifo()（命名）+ open()/read()/write()系统调用，适合轻量通信。</li><li>共享内存：shmget()/shmat()（System V）或mmap()（POSIX），配合sem_init()（信号量）同步，适合高性能场景。</li><li>Socket：通过 BSD Socket API（socket()/connect()/send()）实现，跨平台需处理 Windows/Linux 差异。</li><li>第三方库：Boost.Interprocess（封装共享内存、消息队列）、Boost.Asio（跨平台 Socket 通信），解决原生 API 的跨平台问题。</li></ul><h2 id="qt中ipc封装" tabindex="-1"><a class="header-anchor" href="#qt中ipc封装"><span>Qt中IPC封装</span></a></h2><table><thead><tr><th><strong>IPC 方式</strong></th><th>Qt 类 / 方法</th><th>适用场景</th></tr></thead><tbody><tr><td>父子进程管道通信</td><td><code>QProcess</code></td><td>主进程启动子进程并传递命令 / 数据（如 IDE 调用编译器）。</td></tr><tr><td>本地 Socket 通信</td><td><code>QLocalServer</code>/<code>QLocalSocket</code></td><td>同一主机非亲缘进程（如桌面应用与后台服务）。</td></tr><tr><td>网络 Socket 通信</td><td><code>QTcpServer</code>/<code>QTcpSocket</code>、<code>QUdpSocket</code></td><td>跨主机通信（如客户端 - 服务器应用）。</td></tr><tr><td>共享内存</td><td><code>QSharedMemory</code></td><td>高频数据共享（如多窗口应用共享大型缓存）。</td></tr><tr><td>信号量同步</td><td><code>QSemaphore</code></td><td>配合共享内存控制并发访问。</td></tr></tbody></table></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav" aria-label="page navigation"><a class="route-link auto-link prev" href="/Yanran_blog/guide/knowledge/Vue.html" aria-label="Vue"><!--[--><div class="hint"><span class="arrow left"></span> Prev</div><div class="link"><span class="external-link">Vue</span></div><!--]--></a><a class="route-link auto-link next" href="/Yanran_blog/guide/knowledge/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" aria-label="数据结构"><!--[--><div class="hint">Next <span class="arrow right"></span></div><div class="link"><span class="external-link">数据结构</span></div><!--]--></a></nav><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/Yanran_blog/assets/app-ZTDKGR0h.js" defer></script>
  </body>
</html>
